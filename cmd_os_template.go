package main

import (
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	metalcloud "github.com/metalsoft-io/metal-cloud-sdk-go/v2"
	"github.com/metalsoft-io/tableformatter"
	"gopkg.in/yaml.v3"

	"github.com/go-git/go-billy/v5/memfs"
	git "github.com/go-git/go-git/v5"

	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/go-git/go-git/v5/plumbing/transport/http"
	diff "github.com/sergi/go-diff/diffmatchpatch"

	memory "github.com/go-git/go-git/v5/storage/memory"

	"github.com/kdomanski/iso9660"

	"github.com/bramvdbogaerde/go-scp"
	"github.com/bramvdbogaerde/go-scp/auth"
	// "golang.org/x/crypto/ssh"

	kh "golang.org/x/crypto/ssh/knownhosts"
)

// Constants used with the build command
const osArchitecture64 = "x86_64"

const bootMethodLocalDrives = "local_drives"
const bootMethodPxeIscsi = "pxe_iscsi"

const bootTypeUEFIOnly = "uefi_only"
const bootTypeLegacyOnly = "classic_only"

const bootloaderConfigFileName = "BOOT.CFG"

const assetTypeDynamic = "text/plain"
const assetTypeBinary = "application/octet-stream"

const assetJSONTypeDynamic = "dynamic"
const assetJSONTypeBinary = "binary"

var osTemplatesCmds = []Command{

	{
		Description:  "Lists available templates.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "list",
		AltPredicate: "ls",
		FlagSet:      flag.NewFlagSet("list templates", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"format": c.FlagSet.String("format", _nilDefaultStr, "The output format. Supported values are 'json','csv','yaml'. The default format is human readable."),
				"usage":  c.FlagSet.String("usage", _nilDefaultStr, "Template's usage"),
			}
		},
		ExecuteFunc: templatesListCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "Create a template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "create",
		AltPredicate: "new",
		FlagSet:      flag.NewFlagSet("create template", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"label":                              c.FlagSet.String("label", _nilDefaultStr, red("(Required)")+" Template's label"),
				"display_name":                       c.FlagSet.String("display-name", _nilDefaultStr, red("(Required)")+" Template's display name"),
				"size":                               c.FlagSet.Int("size", _nilDefaultInt, "Template's size (bytes)"),
				"boot_methods_supported":             c.FlagSet.String("boot-methods-supported", _nilDefaultStr, red("(Required)")+" Template boot methods supported. Defaults to pxe_iscsi."),
				"os_bootstrap_function_name":         c.FlagSet.String("os-bootstrap-function-name", _nilDefaultStr, "Optional property that selects the cloudinit configuration function. Can be one of: provisioner_os_cloudinit_prepare_centos, provisioner_os_cloudinit_prepare_rhel, provisioner_os_cloudinit_prepare_ubuntu, provisioner_os_cloudinit_prepare_windows."),
				"boot_type":                          c.FlagSet.String("boot-type", _nilDefaultStr, red("(Required)")+" Template boot type. Possible values: 'uefi_only','legacy_only' "),
				"description":                        c.FlagSet.String("description", _nilDefaultStr, "Template description"),
				"os_type":                            c.FlagSet.String("os-type", _nilDefaultStr, red("(Required)")+" Template operating system type. For example, Ubuntu or CentOS."),
				"os_version":                         c.FlagSet.String("os-version", _nilDefaultStr, red("(Required)")+" Template operating system version."),
				"os_architecture":                    c.FlagSet.String("os-architecture", _nilDefaultStr, red("(Required)")+" Template operating system architecture.Possible values: none, unknown, x86, x86_64."),
				"initial_user":                       c.FlagSet.String("initial-user", _nilDefaultStr, red("(Required)")+" Template's initial username, used to verify install."),
				"initial_password":                   c.FlagSet.String("initial-password", _nilDefaultStr, red("(Required)")+" Template's initial password, used to verify install."),
				"use_autogenerated_initial_password": c.FlagSet.Bool("use-autogenerated-initial-password", false, green("(Flag)")+" If set will automatically generate a password for the template and provide it during install via the initial_password and initial_user variables. Cannot be used withinitial-password and initial-user params."),
				"initial_ssh_port":                   c.FlagSet.Int("initial-ssh-port", _nilDefaultInt, red("(Required)")+" Template's initial ssh port, used to verify install."),
				"change_password_after_deploy":       c.FlagSet.Bool("change-password-after-deploy", false, "Option to change the initial_user password on the installed OS after deploy."),
				"image_build_required":               c.FlagSet.Bool("image-build-required", false, green("(Flag)")+" If set will determine the image building process building an ISO. Needed for the OOB only install process."),
				"provision_via_oob":                  c.FlagSet.Bool("provision-via-oob", false, green("(Flag)")+" If set will perform the installation process via the OOB. Always set this together with the image-build-required flag."),
				"repo_url":                           c.FlagSet.String("repo-url", _nilDefaultStr, "Template's location the repository"),
				"os_ready_method":                    c.FlagSet.String("os-ready-method", _nilDefaultStr, "Possible values: 'wait_for_ssh', 'wait_for_signal_from_os'. Default value: 'wait_for_ssh'."),
				"os_asset_id_bootloader_local_install_id_or_name": c.FlagSet.String("install-bootloader-asset", _nilDefaultStr, "Template's bootloader asset id during install"),
				"os_asset_id_bootloader_os_boot_id_or_name":       c.FlagSet.String("os-boot-bootloader-asset", _nilDefaultStr, "Template's bootloader asset id during regular server boot"),
				"version": c.FlagSet.String("version", _nilDefaultStr, "Template version. Default value is 0.0.0"),

				"return-id": c.FlagSet.Bool("return-id", false, green("(Flag)")+" If set will print the ID of the created infrastructure. Useful for automating tasks."),
			}
		},
		ExecuteFunc: templateCreateCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "Edit a template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "update",
		AltPredicate: "edit",
		FlagSet:      flag.NewFlagSet("update template", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name":        c.FlagSet.String("id", _nilDefaultStr, red("(Required)")+" Template's id or label"),
				"label":                      c.FlagSet.String("label", _nilDefaultStr, red("(Required)")+" Template's label"),
				"display_name":               c.FlagSet.String("display-name", _nilDefaultStr, red("(Required)")+" Template's display name"),
				"size":                       c.FlagSet.Int("size", _nilDefaultInt, "Template's size (bytes)"),
				"boot_methods_supported":     c.FlagSet.String("boot-methods-supported", _nilDefaultStr, "Template boot methods supported. Defaults to pxe_iscsi."),
				"os_bootstrap_function_name": c.FlagSet.String("os-bootstrap-function-name", _nilDefaultStr, "Optional property that selects the cloudinit configuration function. Can be one of: provisioner_os_cloudinit_prepare_centos, provisioner_os_cloudinit_prepare_rhel, provisioner_os_cloudinit_prepare_ubuntu, provisioner_os_cloudinit_prepare_windows."),
				"boot_type":                  c.FlagSet.String("boot-type", _nilDefaultStr, red("(Required)")+" Template boot type. Possible values: 'uefi_only','legacy_only' "),
				"description":                c.FlagSet.String("description", _nilDefaultStr, "Template description"),
				"os_type":                    c.FlagSet.String("os-type", _nilDefaultStr, red("(Required)")+" Template operating system type. For example, Ubuntu or CentOS."),
				"os_version":                 c.FlagSet.String("os-version", _nilDefaultStr, red("(Required)")+" Template operating system version."),
				"os_architecture":            c.FlagSet.String("os-architecture", _nilDefaultStr, red("(Required)")+" Template operating system architecture.Possible values: none, unknown, x86, x86_64."),
				"os_asset_id_bootloader_local_install_id_or_name": c.FlagSet.String("install-bootloader-asset", _nilDefaultStr, "Template's bootloader asset id during install"),
				"os_asset_id_bootloader_os_boot_id_or_name":       c.FlagSet.String("os-boot-bootloader-asset", _nilDefaultStr, "Template's bootloader asset id during regular server boot"),
				"initial_user":                       c.FlagSet.String("initial-user", _nilDefaultStr, red("(Required)")+" Template's initial username, used to verify install."),
				"initial_password":                   c.FlagSet.String("initial-password", _nilDefaultStr, red("(Required)")+" Template's initial password, used to verify install."),
				"use_autogenerated_initial_password": c.FlagSet.Bool("use-autogenerated-initial-password", false, green("(Flag)")+" If set will automatically generate a password for the template and provide it during install via the initial_password and initial_user variables. Cannot be used with --initial-password, requires --initial-user params."),
				"initial_ssh_port":                   c.FlagSet.Int("initial-ssh-port", _nilDefaultInt, red("(Required)")+" Template's initial ssh port, used to verify install."),
				"os_ready_method":                    c.FlagSet.String("os-ready-method", _nilDefaultStr, "Possible values: 'wait_for_ssh', 'wait_for_signal_from_os'. Default value: 'wait_for_ssh'."),
				"change_password_after_deploy":       c.FlagSet.Bool("change-password-after-deploy", false, "Option to change the initial_user password on the installed OS after deploy."),
				"image_build_required":               c.FlagSet.Bool("image-build-required", false, green("(Flag)")+" If set will determine the image building process building an ISO. Needed for the OOB only install process."),
				"provision_via_oob":                  c.FlagSet.Bool("provision-via-oob", false, green("(Flag)")+" If set will perform the installation process via the OOB. Always set this together with the image-build-required flag."),
				"repo_url":                           c.FlagSet.String("repo-url", _nilDefaultStr, "Template description"),
			}
		},
		ExecuteFunc: templateEditCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "Get a template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "get",
		AltPredicate: "show",
		FlagSet:      flag.NewFlagSet("get template", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", _nilDefaultStr, "Asset's id or name"),
				"format":              c.FlagSet.String("format", _nilDefaultStr, "The output format. Supported values are 'json','csv','yaml'. The default format is human readable."),
				"show_credentials":    c.FlagSet.Bool("show-credentials", false, green("(Flag)")+" If set returns the templates initial ssh credentials"),
			}
		},
		ExecuteFunc: templateGetCmd,
		Endpoint:    DeveloperEndpoint,
	},
	{
		Description:  "Delete a template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "delete",
		AltPredicate: "rm",
		FlagSet:      flag.NewFlagSet("delete template", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", _nilDefaultStr, "Asset's id or name"),
				"autoconfirm":         c.FlagSet.Bool("autoconfirm", false, green("(Flag)")+" If set it will assume action is confirmed"),
			}
		},
		ExecuteFunc: templateDeleteCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "Allow other users of the platform to use the template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "make-public",
		AltPredicate: "public",
		FlagSet:      flag.NewFlagSet("make template public", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", _nilDefaultStr, "Template id or name"),
			}
		},
		ExecuteFunc: templateMakePublicCmd,
		Endpoint:    DeveloperEndpoint,
	},
	{
		Description:  "Stop other users of the platform from being able to use the template by allocating a specific owner.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "make-private",
		AltPredicate: "private",
		FlagSet:      flag.NewFlagSet("make template private", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", _nilDefaultStr, "Template id or name"),
				"user_id":             c.FlagSet.String("user-id", _nilDefaultStr, "New owner user id or email."),
			}
		},
		ExecuteFunc: templateMakePrivateCmd,
		Endpoint:    DeveloperEndpoint,
	},
	{
		Description:  "List associated assets.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "list-assets",
		AltPredicate: "assoc",
		FlagSet:      flag.NewFlagSet("associated assets", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", _nilDefaultStr, "Template's id or name"),
			}
		},
		ExecuteFunc: templateListAssociatedAssetsCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "Build an OS template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "build",
		AltPredicate: "build",
		FlagSet:      flag.NewFlagSet("build an OS template from a source ISO image", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"name":                 c.FlagSet.String("name", _nilDefaultStr, red("(Required)")+"Name of image."),
				"source-template":      c.FlagSet.String("source-template", _nilDefaultStr, red("(Required)")+"The source template to use as a base. Use --list-supported for a list of accepted values."),
				"source-iso":           c.FlagSet.String("source-iso", _nilDefaultStr, red("(Required)")+"The source ISO image path."),
				"kickstart":            c.FlagSet.String("kickstart", _nilDefaultStr, yellow("(Optional)")+"The OS's kickstart or equivalent file to be uploaded instead of the default."),
				"kickstart-append":     c.FlagSet.String("kickstart-append", _nilDefaultStr, yellow("(Optional)")+"Content to append to the default kickstart."),
				"bootloader":           c.FlagSet.String("bootloader", _nilDefaultStr, yellow("(Optional)")+"The OS's instalation bootloader to be uploaded instead of default."),
				"bootloader-config":    c.FlagSet.String("bootloader-config", _nilDefaultStr, yellow("(Optional)")+"The OS's installation bootloader config file to be uploaded instead of the default."),
				"other-assets-json":    c.FlagSet.String("other-assets-json", _nilDefaultStr, yellow("(Optional)")+"Dynamic or binary files that will be replaced inside the template. Can contain variables. Limited to 2MB in size."),
				"github-template-repo": c.FlagSet.String("github-template-repo", _nilDefaultStr, yellow("(Optional)")+"Override the default github url used to download template files for given OS."),
				"list-supported":       c.FlagSet.Bool("list-supported", false, yellow("(Optional)")+"List supported OS source templates."),
				"list-warnings":        c.FlagSet.Bool("list-warnings", false, yellow("(Optional)")+"List warnings regarding the repository template structure."),
				"skip-upload-to-repo":  c.FlagSet.Bool("skip-upload-to-repo", false, yellow("(Optional)")+"Skip ISO image upload to the HTTP repository."),
				"quiet":                c.FlagSet.Bool("quiet", false, green("(Flag)")+"If set, eliminates all output."),
				"debug":                c.FlagSet.Bool("debug", false, green("(Flag)")+"If set, increases log level."),
				"return-id":            c.FlagSet.Bool("return-id", false, green("(Flag)")+"If set, returns the ID of the generated template. Useful for automation."),
			}
		},
		ExecuteFunc: templateBuildCmd,
		Endpoint:    ExtendedEndpoint,
		Example: `
	metalcloud-cli os-template build --name="test-template" --source-template="ESXi/7.0.0u3" --source-iso="VMware-VMvisor-Installer-7.0.0.update03-19193900.x86_64-DellEMC_Customized-A02.iso" --kickstart="custom_kickstart.txt" --bootloader="custom_boot.CFG" --bootloader-config="custom_bootloader_config.CFG" --other-assets-json='[{\"path\":\"custom_dynamic_file_1.png\", \"isopath\":\"/dynamic_file_1.jpg\", \"type\":\"dynamic\"}, {\"path\":\"custom_dynamic_file_2.png\", \"isopath\":\"/dynamic_file_3.jpg\", \"type\":\"dynamic\"}, {\"path\":\"custom_binary_file_1.bin\", \"isopath\":\"/binary_file_1.bin\", \"type\":\"binary\"}, {\"path\":\"custom_binary_file_2.bin\", \"isopath\":\"/binary_file_2.bin\", \"type\":\"binary\"}]'
		`,
	},
	{
		Description:  "Create a diff file.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "create-diff",
		AltPredicate: "diff",
		FlagSet:      flag.NewFlagSet("create the diff of 2 files", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"file1": c.FlagSet.String("file1", _nilDefaultStr, red("(Required)")+"Path of the first file."),
				"file2": c.FlagSet.String("file2", _nilDefaultStr, red("(Required)")+"Path of the second file."),
			}
		},
		ExecuteFunc: templateDiffCmd,
		Endpoint:    ExtendedEndpoint,
	},
}

func templatesListCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {

	list, err := client.OSTemplates()

	if err != nil {
		return "", err
	}

	schema := []tableformatter.SchemaField{
		{
			FieldName: "ID",
			FieldType: tableformatter.TypeInt,
			FieldSize: 2,
		},
		{
			FieldName: "LABEL",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "NAME",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "DESCRIPTION",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "SIZE_MBYTES",
			FieldType: tableformatter.TypeInt,
			FieldSize: 5,
		},
		{
			FieldName: "BOOT_METHODS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "OS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "INSTALL_BOOTLOADER",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "OS_BOOTLOADER",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "USER_ID",
			FieldType: tableformatter.TypeInt,
			FieldSize: 5,
		},
		{
			FieldName: "CREATED",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "UPDATED",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
	}

	data := [][]interface{}{}
	for _, s := range *list {

		installBootloader := ""
		if s.OSAssetBootloaderLocalInstall != 0 {
			asset, err := client.OSAssetGet(s.OSAssetBootloaderLocalInstall)
			if err != nil {
				return "", err
			}
			installBootloader = asset.OSAssetFileName
		}
		osBootloader := ""
		if s.OSAssetBootloaderOSBoot != 0 {
			asset, err := client.OSAssetGet(s.OSAssetBootloaderOSBoot)
			if err != nil {
				return "", err
			}
			osBootloader = asset.OSAssetFileName
		}

		osData := ""

		if s.VolumeTemplateOperatingSystem != nil {
			os := *s.VolumeTemplateOperatingSystem
			osData = fmt.Sprintf("%s %s %s",
				os.OperatingSystemType,
				os.OperatingSystemVersion,
				os.OperatingSystemArchitecture)
		}

		data = append(data, []interface{}{
			s.VolumeTemplateID,
			s.VolumeTemplateLabel,
			s.VolumeTemplateDisplayName,
			s.VolumeTemplateDescription,
			s.VolumeTemplateSizeMBytes,
			s.VolumeTemplateBootMethodsSupported,
			osData,
			installBootloader,
			osBootloader,
			s.UserID,
			s.VolumeTemplateCreatedTimestamp,
			s.VolumeTemplateUpdatedTimestamp,
		})

	}

	tableformatter.TableSorter(schema).OrderBy(schema[0].FieldName).Sort(data)

	table := tableformatter.Table{
		Data:   data,
		Schema: schema,
	}
	return table.RenderTable("Templates", "", getStringParam(c.Arguments["format"]))
}

func templateCreateCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {
	obj := metalcloud.OSTemplate{}
	updatedObj, err := updateTemplateFromCommand(obj, c, client, true)
	if err != nil {
		return "", err
	}

	ret, err := client.OSTemplateCreate(*updatedObj)
	if err != nil {
		return "", err
	}

	if getBoolParam(c.Arguments["return-id"]) {
		return fmt.Sprintf("%d", ret.VolumeTemplateID), nil
	}

	return "", err
}

func templateEditCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {

	obj, err := getOSTemplateFromCommand("id", c, client, false)
	if err != nil {
		return "", err
	}
	newobj := metalcloud.OSTemplate{}
	updatedObj, err := updateTemplateFromCommand(newobj, c, client, false)
	if err != nil {
		return "", err
	}

	_, err = client.OSTemplateUpdate(obj.VolumeTemplateID, *updatedObj)

	return "", err
}

func updateTemplateFromCommand(obj metalcloud.OSTemplate, c *Command, client metalcloud.MetalCloudClient, checkRequired bool) (*metalcloud.OSTemplate, error) {
	if v, ok := getStringParamOk(c.Arguments["version"]); ok {
		obj.VolumeTemplateVersion = v
	}

	if v, ok := getStringParamOk(c.Arguments["os_ready_method"]); ok {
		obj.VolumeTemplateOSReadyMethod = v
	}

	if v, ok := getStringParamOk(c.Arguments["os_bootstrap_function_name"]); ok {
		obj.VolumeTemplateOsBootstrapFunctionName = v
	}

	if v, ok := getStringParamOk(c.Arguments["label"]); ok {
		obj.VolumeTemplateLabel = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("label is required")
		}
	}

	if v, ok := getStringParamOk(c.Arguments["display_name"]); ok {
		obj.VolumeTemplateDisplayName = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("display-name is required")
		}
	}

	if v, ok := getIntParamOk(c.Arguments["size"]); ok {
		obj.VolumeTemplateSizeMBytes = v
	}

	obj.VolumeTemplateIsOSTemplate = true

	if v, ok := getStringParamOk(c.Arguments["boot_methods_supported"]); ok {
		obj.VolumeTemplateBootMethodsSupported = v
	}

	if v, ok := getStringParamOk(c.Arguments["boot_type"]); ok {
		obj.VolumeTemplateBootType = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("boot-type is required")
		}
	}

	if v, ok := getStringParamOk(c.Arguments["description"]); ok {
		obj.VolumeTemplateDescription = v
	}

	//OS Data
	os, err := getOperatingSystemFromCommand(c)

	if err != nil {
		return nil, err
	} else if checkRequired && *os == (metalcloud.OperatingSystem{}) {
		return nil, fmt.Errorf("os flags are required")
	}
	if *os != (metalcloud.OperatingSystem{}) {
		obj.VolumeTemplateOperatingSystem = os
	}

	//Network OS Data
	nos, err := getNetworkOperatingSystemFromCommand(c)

	if err != nil {
		return nil, err
	}
	if *nos != (metalcloud.NetworkOperatingSystem{}) {
		obj.VolumeTemplateNetworkOperatingSystem = nos
	}

	// Boot options

	if _, ok := getStringParamOk(c.Arguments["os_asset_id_bootloader_local_install_id_or_name"]); ok {
		localInstallAsset, err := getOSAssetFromCommand("install_bootloader_asset", "os_asset_id_bootloader_local_install_id_or_name", c, client)
		if err != nil {
			return nil, err
		}
		obj.OSAssetBootloaderLocalInstall = localInstallAsset.OSAssetID
	}

	if _, ok := getStringParamOk(c.Arguments["os_asset_id_bootloader_os_boot_id_or_name"]); ok {
		osBootBootloaderAsset, err := getOSAssetFromCommand("os_boot_bootloader_asset", "os_asset_id_bootloader_os_boot_id_or_name", c, client)
		if err != nil {
			return nil, err
		}
		obj.OSAssetBootloaderOSBoot = osBootBootloaderAsset.OSAssetID
	}

	//Credentials

	creds, err := getCredentialsFromCommand(c, checkRequired)

	if err != nil {
		return nil, err
	}

	if *creds != (metalcloud.OSTemplateCredentials{}) {
		obj.OSTemplateCredentials = creds
	}

	if v, ok := getStringParamOk(c.Arguments["repo_url"]); ok {
		obj.VolumeTemplateRepoURL = v
	}

	obj.VolumeTemplateImageBuildRequired = getBoolParam(c.Arguments["image_build_required"])
	obj.VolumeTemplateProvisionViaOOB = getBoolParam(c.Arguments["provision_via_oob"])

	return &obj, nil
}

func getCredentialsFromCommand(c *Command, checkRequired bool) (*metalcloud.OSTemplateCredentials, error) {
	var creds = metalcloud.OSTemplateCredentials{}

	if getBoolParam(c.Arguments["use_autogenerated_initial_password"]) {

		creds.OSTemplateUseAutogeneratedInitialPassword = true

		if _, ok := getStringParamOk(c.Arguments["initial_password"]); ok {
			return nil, fmt.Errorf("--initial-password cannot be used with --use-autogenerated-initial-password")
		}

	} else {

		if v, ok := getStringParamOk(c.Arguments["initial_password"]); ok {
			creds.OSTemplateInitialPassword = v
		} else {
			if checkRequired {
				return nil, fmt.Errorf("either --initial-password or --use-autogenerated-initial-password is required")
			}
		}
	}

	if v, ok := getStringParamOk(c.Arguments["initial_user"]); ok {

		creds.OSTemplateInitialUser = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("initial-user is required")
		}
	}

	if v, ok := getIntParamOk(c.Arguments["initial_ssh_port"]); ok {
		creds.OSTemplateInitialSSHPort = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("initial-ssh-port is required")
		}
	}

	creds.OSTemplateChangePasswordAfterDeploy = getBoolParam(c.Arguments["change_password_after_deploy"])

	return &creds, nil
}

func templateDeleteCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {

	retS, err := getOSTemplateFromCommand("id", c, client, false)
	if err != nil {
		return "", err
	}
	confirm := false

	if getBoolParam(c.Arguments["autoconfirm"]) {
		confirm = true
	} else {

		confirmationMessage := fmt.Sprintf("Deleting template %s (%d).  Are you sure? Type \"yes\" to continue:",
			retS.VolumeTemplateDisplayName,
			retS.VolumeTemplateID)

		//this is simply so that we don't output a text on the command line under go test
		if strings.HasSuffix(os.Args[0], ".test") {
			confirmationMessage = ""
		}

		confirm, err = requestConfirmation(confirmationMessage)
		if err != nil {
			return "", err
		}

	}

	if !confirm {
		return "", fmt.Errorf("Operation not confirmed. Aborting")
	}

	err = client.OSTemplateDelete(retS.VolumeTemplateID)

	return "", err
}

func templateGetCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {

	showCredentials := false
	if c.Arguments["show_credentials"] != nil && *c.Arguments["show_credentials"].(*bool) {
		showCredentials = true
	}

	template, err := getOSTemplateFromCommand("id", c, client, showCredentials)
	if err != nil {
		return "", err
	}

	if err != nil {
		return "", err
	}

	schema := []tableformatter.SchemaField{
		{
			FieldName: "ID",
			FieldType: tableformatter.TypeInt,
			FieldSize: 2,
		},
		{
			FieldName: "LABEL",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "NAME",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "DESCRIPTION",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "SIZE_MBYTES",
			FieldType: tableformatter.TypeInt,
			FieldSize: 5,
		},
		{
			FieldName: "BOOT_METHODS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "OS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "USER_ID",
			FieldType: tableformatter.TypeInt,
			FieldSize: 5,
		},
		{
			FieldName: "INSTALL_BOOTLOADER",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "OS_BOOTLOADER",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "CREATED",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "UPDATED",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
	}

	data := [][]interface{}{}

	credentials := ""

	if showCredentials && template.OSTemplateCredentials != nil {

		schema = append(schema, tableformatter.SchemaField{
			FieldName: "CREDENTIALS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		})

		credentials = fmt.Sprintf("user:%s (port %d) passwd:%s (change_password_after_install:%v)",
			template.OSTemplateCredentials.OSTemplateInitialUser,
			template.OSTemplateCredentials.OSTemplateInitialSSHPort,
			template.OSTemplateCredentials.OSTemplateInitialPassword,
			template.OSTemplateCredentials.OSTemplateChangePasswordAfterDeploy)

	}
	osDetails := ""

	if template.VolumeTemplateOperatingSystem != nil {
		os := *template.VolumeTemplateOperatingSystem
		osDetails = fmt.Sprintf("%s %s %s",
			os.OperatingSystemType,
			os.OperatingSystemVersion,
			os.OperatingSystemArchitecture)
	}

	installBootloader := ""
	if template.OSAssetBootloaderLocalInstall != 0 {
		asset, err := client.OSAssetGet(template.OSAssetBootloaderLocalInstall)
		if err != nil {
			return "", err
		}
		installBootloader = asset.OSAssetFileName
	}
	osBootloader := ""
	if template.OSAssetBootloaderOSBoot != 0 {
		asset, err := client.OSAssetGet(template.OSAssetBootloaderOSBoot)
		if err != nil {
			return "", err
		}
		osBootloader = asset.OSAssetFileName
	}

	data = append(data, []interface{}{
		template.VolumeTemplateID,
		template.VolumeTemplateLabel,
		template.VolumeTemplateDisplayName,
		template.VolumeTemplateDescription,
		template.VolumeTemplateSizeMBytes,
		template.VolumeTemplateBootMethodsSupported,
		osDetails,
		template.UserID,
		installBootloader,
		osBootloader,
		template.VolumeTemplateCreatedTimestamp,
		template.VolumeTemplateUpdatedTimestamp,
		credentials,
	})

	topLine := fmt.Sprintf("Template %s (%d)\n", template.VolumeTemplateLabel, template.VolumeTemplateID)

	tableformatter.TableSorter(schema).OrderBy(
		schema[0].FieldName,
		schema[1].FieldName).Sort(data)

	table := tableformatter.Table{
		Data:   data,
		Schema: schema,
	}
	return table.RenderTable("Templates", topLine, getStringParam(c.Arguments["format"]))
}

func templateMakePublicCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {
	template, err := getOSTemplateFromCommand("id", c, client, false)

	if err != nil {
		return "", err
	}

	err = client.OSTemplateMakePublic(template.VolumeTemplateID)

	if err != nil {
		return "", err
	}

	return "", nil
}

func templateMakePrivateCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {
	template, err := getOSTemplateFromCommand("id", c, client, false)

	if err != nil {
		return "", err
	}

	user, err := getUserFromCommand("user-id", c, client)

	if err != nil {
		return "", err
	}

	if err = client.OSTemplateMakePrivate(template.VolumeTemplateID, user.UserID); err != nil {
		return "", err
	}

	return "", nil
}

func templateBuildCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {

	// TODO: replace with real hostname after finishing development
	imageRepositoryHostname := "192.168.74.1:4022"

	if userGivenImageRepositoryHostname := os.Getenv("METALCLOUD_IMAGE_REPOSITORY_HOSTNAME"); userGivenImageRepositoryHostname != "" {
		imageRepositoryHostname = os.Getenv("METALCLOUD_IMAGE_REPOSITORY_HOSTNAME")
	}

	cloneOptions := new(git.CloneOptions)
	cloneOptions.Depth = 1 // We are only interested in the last commit

	if repositoryName, ok := getStringParamOk(c.Arguments["github-template-repo"]); ok {
		if userPrivateToken := os.Getenv("METALCLOUD_USER_PRIVATE_REPOSITORY_TOKEN"); userPrivateToken == "" {
			return "", fmt.Errorf("METALCLOUD_USER_PRIVATE_REPOSITORY_TOKEN must be set when using a user given repository.")
		}

		cloneOptions.Auth = &http.BasicAuth{
			Password: os.Getenv("METALCLOUD_USER_PRIVATE_REPOSITORY_TOKEN"),
		}

		cloneOptions.URL = repositoryName
	} else {
		// The default repository that is used if the user doesn't specify another one
		cloneOptions.URL = "https://github.com/alexcorman/os-templates.git"
	}

	fmt.Printf("Retrieving asset templates from repository %s.\n", cloneOptions.URL)

	// Filesystem abstraction based on memory
	fs := memfs.New()

	// Git objects storer based on memory
	storer := memory.NewStorage()

	// Clones the repository into the worktree (fs) and storer all the .git
	// content into the storer
	repo, err := git.Clone(storer, fs, cloneOptions)

	if err != nil {
		if err.Error() == "authentication required" {
			return "", fmt.Errorf("Failed to authenticate to the given repository. Please check if the repository exists and/or the given access token is valid.")
		}

		return "", err
	}

	// Retrieve the HEAD reference
	ref, err := repo.Head()

	if err != nil {
		return "", err
	}

	commit, err := repo.CommitObject(ref.Hash())

	if err != nil {
		return "", err
	}

	tree, err := commit.Tree()

	if err != nil {
		return "", err
	}

	type TemplateAsset struct {
		file               object.File
		Isopath            string `yaml:"isopath"`
		Mime               string `yaml:"mime"`
		IsKickstartFile    bool   `yaml:"is-kickstart-file"`
		IsBootloaderConfig bool   `yaml:"is-bootloader-config"`
		IsPatchFile        bool   `yaml:"is-patch-file"`
	}

	type OsTemplateContents struct {
		BootType                        string `yaml:"boot-type"`
		BootMethodsSupported            string `yaml:"boot-methods-supported"`
		OsArchitecture                  string `yaml:"os-architecture"`
		OsReadyMethod                   string `yaml:"os-ready-method"`
		ImageBuildRequired              bool   `yaml:"image-build-required"`
		ProvisionViaOob                 bool   `yaml:"provision-via-oob"`
		InitialUser                     string `yaml:"initial-user"`
		InitialSSHPort                  int    `yaml:"initial-ssh-port"`
		UseAutogeneratedInitialPassword bool   `yaml:"use-autogenerated-initial-password"`
	}

	type TemplateContents struct {
		OsTemplateContents OsTemplateContents       `yaml:"os-template"`
		Assets             map[string]TemplateAsset `yaml:"assets"`
	}

	// Struct containing the values that will be printed out for a repo template
	type RepoTemplate struct {
		Family             string
		Version            string
		Architecture       string
		DeployProcess      string
		BootType           string
		TemplateFile       object.File
		OsTemplateContents OsTemplateContents
		Assets             []TemplateAsset
		Warnings           []string
	}

	repoMap := make(map[string]RepoTemplate)

	// This map stores all files for a template and will be used to check if their information is correct
	repoAssetsPerTemplate := make(map[string][]TemplateAsset)

	files := tree.Files()
	files.ForEach(func(file *object.File) error {
		if file.Mode.IsRegular() {
			if strings.Count(file.Name, "/") == 2 {
				parts := strings.Split(file.Name, "/")
				templatePreffix := strings.Join(parts[:2], "/")

				if parts[2] == "template.yaml" {
					if _, ok := repoMap[templatePreffix]; !ok {
						repoMap[templatePreffix] = RepoTemplate{
							Family:       parts[0],
							Version:      parts[1],
							TemplateFile: *file,
						}
					}
				} else {
					asset := TemplateAsset{
						file: *file,
					}

					repoAssetsPerTemplate[templatePreffix] = append(repoAssetsPerTemplate[templatePreffix], asset)
				}
			}
		}

		return nil
	})

	for templatePreffix, repoTemplate := range repoMap {
		repoTemplate.Assets = repoAssetsPerTemplate[templatePreffix]

		templateStringContents, err := repoTemplate.TemplateFile.Contents()

		if err != nil {
			return "", err
		}

		var templateContents TemplateContents
		err = yaml.Unmarshal([]byte(templateStringContents), &templateContents)

		if err != nil {
			return "", err
		}

		repoTemplate.OsTemplateContents = templateContents.OsTemplateContents

		architecture := templateContents.OsTemplateContents.OsArchitecture
		deployProcess := templateContents.OsTemplateContents.BootMethodsSupported
		bootType := templateContents.OsTemplateContents.BootType

		validArchitectures := []string{osArchitecture64}
		validDeployProcesses := []string{bootMethodLocalDrives, bootMethodPxeIscsi}
		validBootTypes := []string{bootTypeUEFIOnly, bootTypeLegacyOnly}
		validMimeTypes := []string{assetTypeBinary, assetTypeDynamic}

		warnings := []string{}

		if !stringInSlice(architecture, validArchitectures) {
			warnings = append(warnings, fmt.Sprintf("Found invalid architecture %s. Valid architectures are %+q.", architecture, validArchitectures))
		}

		if !stringInSlice(deployProcess, validDeployProcesses) {
			warnings = append(warnings, fmt.Sprintf("Found invalid boot method %s. Valid boot methods are %+q.", deployProcess, validDeployProcesses))
		}

		if !stringInSlice(bootType, validBootTypes) {
			warnings = append(warnings, fmt.Sprintf("Found invalid boot type %s. Valid boot types are %+q.", bootType, validBootTypes))
		}

		var repoFileNames, templateFileNames []string

		for key, asset := range repoTemplate.Assets {
			fileName := strings.ReplaceAll(asset.file.Name, templatePreffix+"/", "")
			repoFileNames = append(repoFileNames, fileName)

			if asset, ok := templateContents.Assets[fileName]; ok {
				repoTemplate.Assets[key].Isopath = asset.Isopath

				if !stringInSlice(asset.Mime, validMimeTypes) {
					warnings = append(warnings, fmt.Sprintf("Found invalid mime type %s for asset %s. Valid mime types are %+q.", asset.Mime, fileName, validDeployProcesses))
				}

				repoTemplate.Assets[key].Mime = asset.Mime
				repoTemplate.Assets[key].IsKickstartFile = asset.IsKickstartFile
				repoTemplate.Assets[key].IsBootloaderConfig = asset.IsBootloaderConfig
				repoTemplate.Assets[key].IsPatchFile = asset.IsPatchFile
			}
		}

		for assetName := range templateContents.Assets {
			templateFileNames = append(templateFileNames, assetName)
		}

		fileNamesNotInTemplate := sliceDifference(repoFileNames, templateFileNames)
		fileNamesNotInRepository := sliceDifference(templateFileNames, repoFileNames)

		if len(fileNamesNotInTemplate) != 0 {
			warnings = append(warnings, fmt.Sprintf("Found the following repository files that are not in the template.yaml file: %+q.", fileNamesNotInTemplate))
		}

		if len(fileNamesNotInRepository) != 0 {
			warnings = append(warnings, fmt.Sprintf("Found the following files declared in template.yaml that are not in the repository: %+q.", fileNamesNotInRepository))
		}

		repoTemplate.Warnings = warnings

		repoTemplate.Architecture = architecture
		repoTemplate.DeployProcess = deployProcess
		repoTemplate.BootType = bootType

		if getBoolParam(c.Arguments["list-warnings"]) {
			// Print warnings, if there are any
			if len(warnings) != 0 {
				fmt.Printf("Detected the following warnings regarding repository structure for template %s:\n", templatePreffix)
			}
			for _, warningMessage := range warnings {
				fmt.Println("\t" + warningMessage)
			}
		}

		repoMap[templatePreffix] = repoTemplate
	}

	fmt.Printf("Retrieved asset templates from repository %s.\n", cloneOptions.URL)

	if getBoolParam(c.Arguments["list-supported"]) {
		schema := []tableformatter.SchemaField{
			{
				FieldName: "FAMILY",
				FieldType: tableformatter.TypeString,
				FieldSize: 5,
			},
			{
				FieldName: "VERSION",
				FieldType: tableformatter.TypeString,
				FieldSize: 5,
			},
			{
				FieldName: "ARCHITECTURE",
				FieldType: tableformatter.TypeString,
				FieldSize: 5,
			},
			{
				FieldName: "DEPLOY PROCESS",
				FieldType: tableformatter.TypeString,
				FieldSize: 5,
			},
			{
				FieldName: "BOOT TYPE",
				FieldType: tableformatter.TypeString,
				FieldSize: 5,
			},
			{
				FieldName: "SOURCE TEMPLATE PATH",
				FieldType: tableformatter.TypeString,
				FieldSize: 5,
			},
		}

		data := [][]interface{}{}
		for templatePreffix, repoTemplate := range repoMap {
			var architecture, deployProcess, bootType string

			switch repoTemplate.Architecture {
			case osArchitecture64:
				architecture = "x64"
			default:
				architecture = red("unknown")
			}

			switch repoTemplate.DeployProcess {
			case bootMethodLocalDrives:
				deployProcess = "virtual_media"
			case bootMethodPxeIscsi:
				deployProcess = "pxe"
			default:
				deployProcess = red("unknown")
			}

			switch repoTemplate.BootType {
			case bootTypeUEFIOnly:
				bootType = "UEFI"
			case bootTypeLegacyOnly:
				bootType = "Legacy"
			default:
				bootType = red("unknown")
			}

			data = append(data, []interface{}{
				repoTemplate.Family,
				repoTemplate.Version,
				architecture,
				deployProcess,
				bootType,
				templatePreffix,
			})

		}

		tableformatter.TableSorter(schema).OrderBy(schema[0].FieldName).Sort(data)

		table := tableformatter.Table{
			Data:   data,
			Schema: schema,
		}
		return table.RenderTable("Repository templates", "", getStringParam(c.Arguments["format"]))
	}

	if name, ok := getStringParamOk(c.Arguments["name"]); ok {

		if sourceTemplateName, ok := getStringParamOk(c.Arguments["source-template"]); ok {
			if _, ok := repoMap[sourceTemplateName]; !ok {
				return "", fmt.Errorf("Did not find source template '%s'. Please use the 'list-supported' parameter to see the supported templates.", sourceTemplateName)
			}

			var imagePath string

			if sourceISO, ok := getStringParamOk(c.Arguments["source-iso"]); ok {
				imagePath = sourceISO
			} else {
				return "", fmt.Errorf("The 'source-iso' parameter must be specified with the 'name' and 'source-template' ones.")
			}

			file, err := os.Open(imagePath)

			if err != nil {
				return "", fmt.Errorf("Image not found at path %s.", imagePath)
			}

			image, err := iso9660.OpenImage(file)

			if err != nil {
				return "", err
			}

			rootDir, err := image.RootDir()

			if err != nil {
				return "", err
			}

			children, err := rootDir.GetChildren()

			if err != nil {
				return "", err
			}

			var bootloaderFile *iso9660.File = nil

			for _, child := range children {
				if !child.IsDir() && child.Name() == bootloaderConfigFileName {
					bootloaderFile = child
					break
				}
			}

			if bootloaderFile == nil {
				return "", fmt.Errorf("Did not find bootloader config file in the given ISO image.")
			}

			bootloaderData, err := ioutil.ReadAll(bootloaderFile.Reader())

			if err != nil {
				return "", err
			}

			sourceTemplate := repoMap[sourceTemplateName]

			var patchAsset TemplateAsset
			foundPatchAsset := false

			for _, asset := range sourceTemplate.Assets {
				if asset.IsPatchFile {

					if foundPatchAsset {
						return "", fmt.Errorf("Found more than one patch asset for source template '%s'. Templates should only have one patch asset for the bootloader.", sourceTemplateName)
					}

					foundPatchAsset = true
					patchAsset = asset
				}
			}

			if !foundPatchAsset {
				return "", fmt.Errorf("Did not find the patch file for source template '%s'.", sourceTemplateName)
			}

			patchFileStringContents, err := patchAsset.file.Contents()

			if err != nil {
				return "", err
			}

			diffMatchPatch := diff.New()

			patches, err := diffMatchPatch.PatchFromText(patchFileStringContents)

			if err != nil {
				return "", err
			}

			patchedText, _ := diffMatchPatch.PatchApply(patches, string(bootloaderData))

			//Remove tabs and blank lines, somehow they get added when applying the patch
			patchedText = strings.ReplaceAll(patchedText, "\t", "")
			patchedText = strings.TrimSpace(patchedText)

			var kickstartContents string

			if filePath, ok := getStringParamOk(c.Arguments["kickstart-append"]); ok {
				kickstartAppendFilePath := filePath

				appendFileContents, err := os.ReadFile(kickstartAppendFilePath)

				if err != nil {
					return "", fmt.Errorf("Kickstart append file not found at path %s.", kickstartAppendFilePath)
				}

				for _, asset := range repoMap[sourceTemplateName].Assets {

					if asset.IsKickstartFile {
						kickstartContents, err = asset.file.Contents()

						if err != nil {
							return "", fmt.Errorf("Did not find the kickstart asset for source template '%s'.", sourceTemplateName)
						}

						kickstartContents += "\n" + string(appendFileContents)
						fmt.Printf("Appended contents from file %s to kickstart asset %s\n.", filePath, asset.file.Name)
						break
					}
				}
			}

			OsTemplateContents := repoMap[sourceTemplateName].OsTemplateContents

			createTemplateCommand := Command{
				Description:  "Create a template.",
				Subject:      "os-template",
				AltSubject:   "template",
				Predicate:    "create",
				AltPredicate: "new",
				FlagSet:      flag.NewFlagSet("create template", flag.ExitOnError),
				ExecuteFunc:  templateCreateCmd,
				Endpoint:     ExtendedEndpoint,
			}

			createTemplateCommand.Arguments = map[string]interface{}{
				"label":                              createTemplateCommand.FlagSet.String("label", name, red("(Required)")+" Template's label"),
				"display_name":                       createTemplateCommand.FlagSet.String("display-name", name, red("(Required)")+" Template's display name"),
				"size":                               createTemplateCommand.FlagSet.Int("size", _nilDefaultInt, "Template's size (bytes)"),
				"boot_methods_supported":             createTemplateCommand.FlagSet.String("boot-methods-supported", OsTemplateContents.BootMethodsSupported, red("(Required)")+" Template boot methods supported. Defaults to pxe_iscsi."),
				"os_bootstrap_function_name":         createTemplateCommand.FlagSet.String("os-bootstrap-function-name", _nilDefaultStr, "Optional property that selects the cloudinit configuration function. Can be one of: provisioner_os_cloudinit_prepare_centos, provisioner_os_cloudinit_prepare_rhel, provisioner_os_cloudinit_prepare_ubuntu, provisioner_os_cloudinit_prepare_windows."),
				"boot_type":                          createTemplateCommand.FlagSet.String("boot-type", OsTemplateContents.BootType, red("(Required)")+" Template boot type. Possible values: 'uefi_only','legacy_only' "),
				"description":                        createTemplateCommand.FlagSet.String("description", name, "Template description"),
				"os_type":                            createTemplateCommand.FlagSet.String("os-type", repoMap[sourceTemplateName].Family, red("(Required)")+" Template operating system type. For example, Ubuntu or CentOS."),
				"os_version":                         createTemplateCommand.FlagSet.String("os-version", repoMap[sourceTemplateName].Version, red("(Required)")+" Template operating system version."),
				"os_architecture":                    createTemplateCommand.FlagSet.String("os-architecture", repoMap[sourceTemplateName].Architecture, red("(Required)")+" Template operating system architecture.Possible values: none, unknown, x86, x86_64."),
				"initial_user":                       createTemplateCommand.FlagSet.String("initial-user", OsTemplateContents.InitialUser, red("(Required)")+" Template's initial username, used to verify install."),
				"initial_password":                   createTemplateCommand.FlagSet.String("initial-password", _nilDefaultStr, red("(Required)")+" Template's initial password, used to verify install."),
				"use_autogenerated_initial_password": createTemplateCommand.FlagSet.Bool("use-autogenerated-initial-password", OsTemplateContents.UseAutogeneratedInitialPassword, green("(Flag)")+" If set will automatically generate a password for the template and provide it during install via the initial_password and initial_user variables. Cannot be used withinitial-password and initial-user params."),
				"initial_ssh_port":                   createTemplateCommand.FlagSet.Int("initial-ssh-port", OsTemplateContents.InitialSSHPort, red("(Required)")+" Template's initial ssh port, used to verify install."),
				"change_password_after_deploy":       createTemplateCommand.FlagSet.Bool("change-password-after-deploy", false, "Option to change the initial_user password on the installed OS after deploy."),
				"image_build_required":               createTemplateCommand.FlagSet.Bool("image-build-required", OsTemplateContents.ImageBuildRequired, green("(Flag)")+" If set will determine the image building process building an ISO. Needed for the OOB only install process."),
				"provision_via_oob":                  createTemplateCommand.FlagSet.Bool("provision-via-oob", OsTemplateContents.ProvisionViaOob, green("(Flag)")+" If set will perform the installation process via the OOB. Always set this together with the image-build-required flag."),
				"repo_url":                           createTemplateCommand.FlagSet.String("repo-url", _nilDefaultStr, "Template's location the repository"),
				"os_ready_method":                    createTemplateCommand.FlagSet.String("os-ready-method", OsTemplateContents.OsReadyMethod, "Possible values: 'wait_for_ssh', 'wait_for_signal_from_os'. Default value: 'wait_for_ssh'."),
				"os_asset_id_bootloader_local_install_id_or_name": createTemplateCommand.FlagSet.String("install-bootloader-asset", _nilDefaultStr, "Template's bootloader asset id during install"),
				"os_asset_id_bootloader_os_boot_id_or_name":       createTemplateCommand.FlagSet.String("os-boot-bootloader-asset", _nilDefaultStr, "Template's bootloader asset id during regular server boot"),
				"version": createTemplateCommand.FlagSet.String("version", _nilDefaultStr, "Template version. Default value is 0.0.0"),
			}

			var templateID int

			_, createError := templateCreateCmd(&createTemplateCommand, client)

			if createError != nil {
				list, err := client.OSTemplates()

				if err != nil {
					return "", err
				}

				templateFound := false

				for _, s := range *list {
					if s.VolumeTemplateLabel == name {
						templateFound = true
						templateID = s.VolumeTemplateID
						break
					}
				}

				if !templateFound {
					return "", createError
				}
			}

			createAssetCommand := Command{
				Description:  "Create asset.",
				Subject:      "asset",
				AltSubject:   "asset",
				Predicate:    "create",
				AltPredicate: "new",
				ExecuteFunc:  assetCreateCmd,
				Endpoint:     DeveloperEndpoint,
			}

			// Struct containing assets that are to be created after all checks are done.
			type Asset struct {
				Name     string
				Command  Command
				Contents string
			}

			assets := []Asset{}

			s := strings.Split(imagePath, "/")
			imageFilename := s[len(s)-1]

			isoPath := imageRepositoryHostname + "/iso/" + name + "/" + imageFilename

			if !getBoolParam(c.Arguments["skip-upload-to-repo"]) {
				homeDir, err := os.UserHomeDir()
				if err != nil {
					return "", err
				}

				var knownHostsFilePath string

				if userGivenHostsFilePath := os.Getenv("METALCLOUD_KNOWN_HOSTS_FILE_PATH"); userGivenHostsFilePath != "" {
					knownHostsFilePath = os.Getenv("METALCLOUD_KNOWN_HOSTS_FILE_PATH")
				} else {
					knownHostsFilePath = filepath.Join(homeDir, ".ssh", "known_hosts.old")

					// Create the known hosts file if it does not exist.
					if _, err := os.Stat(knownHostsFilePath); errors.Is(err, os.ErrNotExist) {
						hostsFile, err := os.Create(knownHostsFilePath)

						if err != nil {
							return "", err
						}

						hostsFile.Close()
					}
				}

				knownHostsFileContents, err := os.ReadFile(knownHostsFilePath)

				if err != nil {
					return "", fmt.Errorf("Hosts file not found at path %s.", knownHostsFilePath)
				}

				fmt.Println(string(knownHostsFileContents))	

				hostKeyCallback, err := kh.New(knownHostsFilePath)

				if err != nil {
					return "", fmt.Errorf("Received following error when parsing the known_hosts file: %s.", err)
				}

				fmt.Printf("%+v\n", hostKeyCallback)

				if userPrivateSSHKeyPath := os.Getenv("METALCLOUD_USER_PRIVATE_OPENSSH_KEY_PATH"); userPrivateSSHKeyPath == "" {
					return "", fmt.Errorf("METALCLOUD_USER_PRIVATE_OPENSSH_KEY_PATH must be set when creating an OS template. The key is needed when uploading to the ISO repository.")
				}

				userPrivateSSHKeyPath := os.Getenv("METALCLOUD_USER_PRIVATE_OPENSSH_KEY_PATH")

				// Use SSH key authentication from the auth package.
				clientConfig, err := auth.PrivateKey("root", userPrivateSSHKeyPath, hostKeyCallback)

				if err != nil {
					return "", fmt.Errorf("Could not create SSH client config. Received error: %s", err)
				}

				// Create a new SCP client.
				scpClient := scp.NewClient(imageRepositoryHostname, &clientConfig)

				// Connect to the remote server.
				err = scpClient.Connect()
				if err != nil {
					return "", fmt.Errorf("Couldn't establish a connection to the remote server: %s", err)
				}

				return "", fmt.Errorf("STOP HERE x1")
			} else {
				fmt.Printf("Skipped uploading image to repository at path %s.", isoPath)
			}

			return "", fmt.Errorf("STOP HERE x2")

			createIsoCommand := createAssetCommand
			createIsoCommand.FlagSet = flag.NewFlagSet("create ISO asset", flag.ExitOnError)
			createIsoCommand.Arguments = map[string]interface{}{
				"filename":               createIsoCommand.FlagSet.String("filename", imageFilename, "Asset's filename"),
				"usage":                  createIsoCommand.FlagSet.String("usage", "build_source_image", "Asset's usage."),
				"mime":                   createIsoCommand.FlagSet.String("mime", assetTypeBinary, "Asset's mime type. Possible values: \""+assetTypeDynamic+"\", \""+assetTypeBinary+"\""),
				"url":                    createIsoCommand.FlagSet.String("url", isoPath, "Asset's source url. If present it will not read content anymore"),
				"read_content_from_pipe": createIsoCommand.FlagSet.Bool("pipe", false, "Read assets's content read from pipe instead of terminal input"),
				"template_id_or_name":    createIsoCommand.FlagSet.String("template-id", name, "Template's id or name to associate. "),
				"path":                   createIsoCommand.FlagSet.String("path", "/source-image", "Path to associate asset to."),
				"variables_json":         createIsoCommand.FlagSet.String("variables-json", _nilDefaultStr, "JSON encoded variables object"),
				"delete_if_exists":       createIsoCommand.FlagSet.Bool("delete-if-exists", true, "Automatically delete the existing asset associated with the current template."),
			}

			assets = append(assets, Asset{
				Name:    imageFilename,
				Command: createIsoCommand,
			})

			var bootConfigPath string

			switch OsTemplateContents.BootType {
			case bootTypeUEFIOnly:
				bootConfigPath = "/EFI/BOOT/BOOT.CFG"
			case bootTypeLegacyOnly:
				bootConfigPath = "/BOOT.CFG"
			}

			bootloaderContents := string(patchedText)
			bootloaderFileName := "BOOT.CFG"

			if filePath, ok := getStringParamOk(c.Arguments["bootloader"]); ok {
				bootloaderFilePath := filePath

				bootloaderFileContents, err := os.ReadFile(bootloaderFilePath)

				if err != nil {
					return "", fmt.Errorf("Bootloader file not found at path %s.", bootloaderFilePath)
				}

				bootloaderContents = string(bootloaderFileContents)

				s := strings.Split(bootloaderFilePath, "/")
				bootloaderFileName = s[len(s)-1]

				fmt.Printf("Replaced template bootloader asset with %s.\n", bootloaderFilePath)
			}

			createBootCommand := createAssetCommand
			createBootCommand.FlagSet = flag.NewFlagSet("create boot asset", flag.ExitOnError)
			createBootCommand.Arguments = map[string]interface{}{
				"filename":               createBootCommand.FlagSet.String("filename", bootloaderFileName, "Asset's filename"),
				"usage":                  createBootCommand.FlagSet.String("usage", "build_component", "Asset's usage."),
				"mime":                   createBootCommand.FlagSet.String("mime", assetTypeDynamic, "Asset's mime type. Possible values: \""+assetTypeDynamic+"\",\""+assetTypeBinary+"\""),
				"url":                    createBootCommand.FlagSet.String("url", _nilDefaultStr, "Asset's source url. If present it will not read content anymore"),
				"read_content_from_pipe": createBootCommand.FlagSet.Bool("pipe", false, "Read assets's content read from pipe instead of terminal input"),
				"template_id_or_name":    createBootCommand.FlagSet.String("template-id", name, "Template's id or name to associate. "),
				"path":                   createBootCommand.FlagSet.String("path", bootConfigPath, "Path to associate asset to."),
				"variables_json":         createBootCommand.FlagSet.String("variables-json", _nilDefaultStr, "JSON encoded variables object"),
				"delete_if_exists":       createBootCommand.FlagSet.Bool("delete-if-exists", true, "Automatically delete the existing asset associated with the current template."),
			}

			assets = append(assets, Asset{
				Name:     bootloaderFileName,
				Command:  createBootCommand,
				Contents: bootloaderContents,
			})

			type InputAsset struct {
				LocalPath string `json:"path"`
				IsoPath   string `json:"isopath"`
				Type      string `json:"type"`
			}

			var otherAssets, dynamicAssets, binaryAssets []InputAsset

			if otherAssetsJSON, ok := getStringParamOk(c.Arguments["other-assets-json"]); ok {
				err := json.Unmarshal([]byte(otherAssetsJSON), &otherAssets)
				if err != nil {
					return "", fmt.Errorf("Invalid 'other-assets-json' value sent. The value sent must be a JSON in this format: '[{\"path\":\"<path_value>\", \"isopath\":\"<isopath_value>\", \"type\":\"<asset_type>\"}, {\"path\":\"<path_value>\", \"isopath\":\"<isopath_value>\", \"type\":\"<asset_type>\"}]'.")
				}

				for _, asset := range otherAssets {
					_, err := os.ReadFile(asset.LocalPath)

					if err != nil {
						return "", fmt.Errorf("Asset not found at path %s.", asset.LocalPath)
					}

					switch asset.Type {
					case assetJSONTypeDynamic:
						dynamicAssets = append(dynamicAssets, asset)
					case assetJSONTypeBinary:
						binaryAssets = append(binaryAssets, asset)
					default:
						return "", fmt.Errorf("Invalid asset type found %s. It must be one of %v.", asset.Type, []string{assetJSONTypeDynamic, assetJSONTypeBinary})
					}

				}
			}

			for _, asset := range repoMap[sourceTemplateName].Assets {

				if asset.IsPatchFile {
					// We skip the patch file, as the boot file has already been created.
					continue
				}

				validMimeTypes := []string{assetTypeBinary, assetTypeDynamic}

				if !asset.IsKickstartFile && !asset.IsBootloaderConfig && !stringInSlice(asset.Mime, validMimeTypes) {
					// We skip the files that are not kickstarts, bootloader configs or have invalid mime type.
					continue
				}

				assetContents, err := asset.file.Contents()

				if err != nil {
					return "", err
				}

				assetFileName := asset.file.Name

				if asset.IsKickstartFile {
					if filePath, ok := getStringParamOk(c.Arguments["kickstart"]); ok {

						if kickstartContents != "" {
							return "", fmt.Errorf("'kickstart' argument cannot be used alongside the 'kickstart-append' one.")
						}
						kickstartFilePath := filePath

						kickstartFileContents, err := os.ReadFile(kickstartFilePath)

						if err != nil {
							return "", fmt.Errorf("Kickstart file not found at path %s.", kickstartFilePath)
						}

						assetContents = string(kickstartFileContents)
						assetFileName = kickstartFilePath

						fmt.Printf("Replaced template kickstart asset with %s.\n", kickstartFilePath)
					} else if kickstartContents != "" {
						// If we have a kickstart file and the kickstart-append option was used, we will use the string with the appended text
						assetContents = kickstartContents
					}
				} else if asset.IsBootloaderConfig {
					if filePath, ok := getStringParamOk(c.Arguments["bootloader-config"]); ok {
						bootloaderConfigFilePath := filePath

						bootloaderConfigFileContents, err := os.ReadFile(bootloaderConfigFilePath)

						if err != nil {
							return "", fmt.Errorf("Bootloader configuration file not found at path %s.", bootloaderConfigFilePath)
						}

						assetContents = string(bootloaderConfigFileContents)
						assetFileName = bootloaderConfigFilePath

						fmt.Printf("Replaced bootloader config asset with %s.\n", bootloaderConfigFilePath)
					}
				} else {
					switch asset.Mime {
					case assetTypeBinary:
						for _, binaryAsset := range binaryAssets {
							fileContents, _ := os.ReadFile(binaryAsset.LocalPath)

							if asset.Isopath == binaryAsset.IsoPath {
								assetContents = string(fileContents)
								assetFileName = binaryAsset.LocalPath

								fmt.Printf("Replaced binary asset with %s.\n", assetFileName)
							}
						}
					case assetTypeDynamic:
						for _, dynamicAsset := range dynamicAssets {
							fileContents, _ := os.ReadFile(dynamicAsset.LocalPath)

							if asset.Isopath == dynamicAsset.IsoPath {
								assetContents = string(fileContents)
								assetFileName = dynamicAsset.LocalPath

								fmt.Printf("Replaced dynamic asset with %s.\n", assetFileName)
							}
						}
					}
				}

				s := strings.Split(assetFileName, "/")
				assetName := s[len(s)-1]

				createOtherAssetCommand := createAssetCommand
				createOtherAssetCommand.FlagSet = flag.NewFlagSet("create asset "+assetName, flag.ExitOnError)
				createOtherAssetCommand.Arguments = map[string]interface{}{
					"filename":               createOtherAssetCommand.FlagSet.String("filename", assetName, "Asset's filename"),
					"usage":                  createOtherAssetCommand.FlagSet.String("usage", "build_component", "Asset's usage."),
					"mime":                   createOtherAssetCommand.FlagSet.String("mime", asset.Mime, "Asset's mime type. Possible values: \""+assetTypeDynamic+"\",\""+assetTypeBinary+"\""),
					"url":                    createOtherAssetCommand.FlagSet.String("url", _nilDefaultStr, "Asset's source url. If present it will not read content anymore"),
					"read_content_from_pipe": createOtherAssetCommand.FlagSet.Bool("pipe", false, "Read assets's content read from pipe instead of terminal input"),
					"template_id_or_name":    createOtherAssetCommand.FlagSet.String("template-id", name, "Template's id or name to associate. "),
					"path":                   createOtherAssetCommand.FlagSet.String("path", asset.Isopath, "Path to associate asset to."),
					"variables_json":         createOtherAssetCommand.FlagSet.String("variables-json", _nilDefaultStr, "JSON encoded variables object"),
					"delete_if_exists":       createOtherAssetCommand.FlagSet.Bool("delete-if-exists", true, "Automatically delete the existing asset associated with the current template."),
				}

				assets = append(assets, Asset{
					Name:     assetName,
					Command:  createOtherAssetCommand,
					Contents: assetContents,
				})
			}

			for _, asset := range assets {
				if asset.Contents != "" {
					_, err = assetCreateWithContentCmd(&asset.Command, client, []byte(asset.Contents))
				} else {
					_, err = assetCreateCmd(&asset.Command, client)
				}

				if err != nil {
					fmt.Printf("Failed to upload asset %s. Received the following error: %s\n", asset.Name, err)
				} else {
					fmt.Printf("Uploaded asset %s.\n", asset.Name)
				}
			}

			fmt.Println("Done.")

			if getBoolParam(c.Arguments["return-id"]) {
				if templateID == 0 {
					list, err := client.OSTemplates()

					if err != nil {
						return "", err
					}

					for _, s := range *list {
						if s.VolumeTemplateLabel == name {
							templateID = s.VolumeTemplateID
							break
						}
					}
				}

				return fmt.Sprintf("%d", templateID), nil
			}

			if err != nil {
				return "", err
			}

		} else {
			return "", fmt.Errorf("The 'source-template' parameter must be specified with the 'name' one.")
		}
	}

	return "", nil
}

func templateDiffCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {
	var filePath1, filePath2 string

	if file1, ok := getStringParamOk(c.Arguments["file1"]); ok {
		filePath1 = file1
	} else {
		return "", fmt.Errorf("did not find the 'file1' parameter")
	}

	if file2, ok := getStringParamOk(c.Arguments["file2"]); ok {
		filePath2 = file2
	} else {
		return "", fmt.Errorf("did not find the 'file2' parameter")
	}

	fileContents1, err := os.ReadFile(filePath1)

	if err != nil {
		return "", err
	}

	fileContents2, err := os.ReadFile(filePath2)

	if err != nil {
		return "", err
	}

	diffMatchPatch := diff.New()

	diffs := diffMatchPatch.DiffMain(string(fileContents1), string(fileContents2), false)
	patches := diffMatchPatch.PatchMake(diffs)
	patchText := diffMatchPatch.PatchToText(patches)

	return patchText, nil
}

func getOSTemplateFromCommand(paramName string, c *Command, client metalcloud.MetalCloudClient, decryptPasswd bool) (*metalcloud.OSTemplate, error) {
	v, err := getParam(c, "template_id_or_name", paramName)
	if err != nil {
		return nil, err
	}

	id, label, isID := idOrLabel(v)

	if isID {
		return client.OSTemplateGet(id, decryptPasswd)
	}

	list, err := client.OSTemplates()
	if err != nil {
		return nil, err
	}

	for _, s := range *list {
		if s.VolumeTemplateLabel == label {
			return &s, nil
		}
	}

	if isID {
		return nil, fmt.Errorf("template %d not found", id)
	}

	return nil, fmt.Errorf("template %s not found", label)
}

func getUserFromCommand(paramName string, c *Command, client metalcloud.MetalCloudClient) (*metalcloud.User, error) {
	user, err := getParam(c, "user_id", paramName)
	if err != nil {
		return nil, err
	}

	id, email, isID := idOrLabel(user)

	if isID {
		return client.UserGet(id)
	} else {
		return client.UserGetByEmail(email)
	}
}

func stringInSlice(a string, list []string) bool {
	for _, b := range list {
		if b == a {
			return true
		}
	}
	return false
}

func sliceDifference(slice1 []string, slice2 []string) []string {
	var diff []string

	for _, s1 := range slice1 {
		found := false

		for _, s2 := range slice2 {
			if s1 == s2 {
				found = true
				break
			}
		}

		if !found {
			diff = append(diff, s1)
		}
	}

	return diff
}
