package main

import (
	"bufio"
	"bytes"
	"context"
	"encoding/base64"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"net"
	"os"
	"path/filepath"
	"strings"

	metalcloud "github.com/metalsoft-io/metal-cloud-sdk-go/v2"
	"github.com/metalsoft-io/tableformatter"
	"gopkg.in/yaml.v3"

	"github.com/go-git/go-billy/v5/memfs"
	git "github.com/go-git/go-git/v5"

	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/go-git/go-git/v5/plumbing/transport/http"
	diff "github.com/sergi/go-diff/diffmatchpatch"

	memory "github.com/go-git/go-git/v5/storage/memory"

	"github.com/kdomanski/iso9660"

	"github.com/bramvdbogaerde/go-scp"
	"github.com/bramvdbogaerde/go-scp/auth"
	"golang.org/x/crypto/ssh"

	kh "golang.org/x/crypto/ssh/knownhosts"

	netHTTP "net/http"
)

// Constants used with the deploy command
const templateFileName = "template.yaml"

const osArchitecture64 = "x86_64"

const bootMethodLocalDrives = "local_drives"
const bootMethodPxeIscsi = "pxe_iscsi"

const bootTypeUEFIOnly = "uefi_only"
const bootTypeLegacyOnly = "legacy_only"

const assetTypeBootloader = "bootloader"
const assetTypeBootloaderConfig = "bootloader-config"
const assetTypeInstallerConfig = "installer-config"
const assetTypePatch = "patch"
const assetTypeOther = "other"

const assetMimeTypeDynamic = "text/plain"
const assetMimeTypeBinary = "application/octet-stream"

const assetUsageTypeBootloader = "bootloader"
const assetUsageTypeBuildComponent = "build_component"

const assetJSONTypeDynamic = "dynamic"
const assetJSONTypeBinary = "binary"

const otherAssetsMaximumSizeBytes = 2097152

const localRepositoryName = "local"
const readMeFileName = "README.md"

const defaultImageRepositorySSHPath = "/home/repo/data/.iso"
const defaultImageRepositorySSHPort = "22"
const defaultImageRepositoryHostname = "repo.metalsoft.io"
const defaultImageRepositoryIsoPath = "/.iso"

type TemplateAsset struct {
	name     string
	contents string
	Isopath  string `yaml:"isopath"`
	Mime     string `yaml:"mime"`
	Usage    string `yaml:"usage"`
	Type     string `yaml:"type"`
	Url      string `yaml:"url"`
	Path     string `yaml:"path"`
}

type OsTemplateContents struct {
	BootType                        string `yaml:"boot-type"`
	BootMethodsSupported            string `yaml:"boot-methods-supported"`
	OsType                          string `yaml:"os-type"`
	OsVersion                       string `yaml:"os-version"`
	OsArchitecture                  string `yaml:"os-architecture"`
	OsReadyMethod                   string `yaml:"os-ready-method"`
	ImageBuildRequired              bool   `yaml:"image-build-required"`
	ProvisionViaOob                 bool   `yaml:"provision-via-oob"`
	InitialUser                     string `yaml:"initial-user"`
	InitialSSHPort                  int    `yaml:"initial-ssh-port"`
	UseAutogeneratedInitialPassword bool   `yaml:"use-autogenerated-initial-password"`
	InstallBootloaderAsset          string `yaml:"install-bootloader-asset"`
	OsBootBootloaderAsset           string `yaml:"os-boot-bootloader-asset"`
}

type TemplateContents struct {
	OsTemplateContents OsTemplateContents       `yaml:"os-template"`
	Assets             map[string]TemplateAsset `yaml:"assets"`
}

// Struct containing the values that will be printed out for a repo template
type RepoTemplate struct {
	Type                 string
	Version              string
	Architecture         string
	DeployProcess        string
	BootType             string
	SourcePath           string
	TemplateFileContents string
	OsTemplateContents   OsTemplateContents
	Assets               map[string]TemplateAsset
	Errors               []string
}

// Struct containing assets that are to be created after all checks are done.
type Asset struct {
	Name     string
	Command  Command
	Contents string
}

var osTemplatesCmds = []Command{

	{
		Description:  "Lists available templates.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "list",
		AltPredicate: "ls",
		FlagSet:      flag.NewFlagSet("list templates", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"format": c.FlagSet.String("format", _nilDefaultStr, "The output format. Supported values are 'json','csv','yaml'. The default format is human readable."),
				"usage":  c.FlagSet.String("usage", _nilDefaultStr, "Template's usage"),
			}
		},
		ExecuteFunc: templatesListCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "Create an empty template record.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "create",
		AltPredicate: "new",
		FlagSet:      flag.NewFlagSet("create template", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"label":                              c.FlagSet.String("label", _nilDefaultStr, red("(Required)")+" Template's label"),
				"display_name":                       c.FlagSet.String("display-name", _nilDefaultStr, red("(Required)")+" Template's display name"),
				"size":                               c.FlagSet.Int("size", _nilDefaultInt, "Template's size (bytes)"),
				"boot_methods_supported":             c.FlagSet.String("boot-methods-supported", _nilDefaultStr, red("(Required)")+" Template boot methods supported. Defaults to pxe_iscsi."),
				"os_bootstrap_function_name":         c.FlagSet.String("os-bootstrap-function-name", _nilDefaultStr, "Optional property that selects the cloudinit configuration function. Can be one of: provisioner_os_cloudinit_prepare_centos, provisioner_os_cloudinit_prepare_rhel, provisioner_os_cloudinit_prepare_ubuntu, provisioner_os_cloudinit_prepare_windows."),
				"boot_type":                          c.FlagSet.String("boot-type", _nilDefaultStr, red("(Required)")+" Template boot type. Possible values: 'uefi_only','legacy_only' "),
				"description":                        c.FlagSet.String("description", _nilDefaultStr, "Template description"),
				"os_type":                            c.FlagSet.String("os-type", _nilDefaultStr, red("(Required)")+" Template operating system type. For example, Ubuntu or CentOS."),
				"os_version":                         c.FlagSet.String("os-version", _nilDefaultStr, red("(Required)")+" Template operating system version."),
				"os_architecture":                    c.FlagSet.String("os-architecture", _nilDefaultStr, red("(Required)")+" Template operating system architecture.Possible values: none, unknown, x86, x86_64."),
				"initial_user":                       c.FlagSet.String("initial-user", _nilDefaultStr, red("(Required)")+" Template's initial username, used to verify install."),
				"initial_password":                   c.FlagSet.String("initial-password", _nilDefaultStr, red("(Required)")+" Template's initial password, used to verify install."),
				"use_autogenerated_initial_password": c.FlagSet.Bool("use-autogenerated-initial-password", false, green("(Flag)")+" If set will automatically generate a password for the template and provide it during install via the initial_password and initial_user variables. Cannot be used withinitial-password and initial-user params."),
				"initial_ssh_port":                   c.FlagSet.Int("initial-ssh-port", _nilDefaultInt, red("(Required)")+" Template's initial ssh port, used to verify install."),
				"change_password_after_deploy":       c.FlagSet.Bool("change-password-after-deploy", false, "Option to change the initial_user password on the installed OS after deploy."),
				"image_build_required":               c.FlagSet.Bool("image-build-required", false, green("(Flag)")+" If set will determine the image building process building an ISO. Needed for the OOB only install process."),
				"provision_via_oob":                  c.FlagSet.Bool("provision-via-oob", false, green("(Flag)")+" If set will perform the installation process via the OOB. Always set this together with the image-build-required flag."),
				"repo_url":                           c.FlagSet.String("repo-url", _nilDefaultStr, "Template's location the repository"),
				"os_ready_method":                    c.FlagSet.String("os-ready-method", _nilDefaultStr, "Possible values: 'wait_for_ssh', 'wait_for_signal_from_os'. Default value: 'wait_for_ssh'."),
				"os_asset_id_bootloader_local_install_id_or_name": c.FlagSet.String("install-bootloader-asset", _nilDefaultStr, "Template's bootloader asset id during install"),
				"os_asset_id_bootloader_os_boot_id_or_name":       c.FlagSet.String("os-boot-bootloader-asset", _nilDefaultStr, "Template's bootloader asset id during regular server boot"),
				"version": c.FlagSet.String("version", _nilDefaultStr, "Template version. Default value is 0.0.0"),

				"return-id": c.FlagSet.Bool("return-id", false, green("(Flag)")+" If set will print the ID of the created infrastructure. Useful for automating tasks."),
			}
		},
		ExecuteFunc: templateCreateCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "Edit a template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "update",
		AltPredicate: "edit",
		FlagSet:      flag.NewFlagSet("update template", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name":        c.FlagSet.String("id", _nilDefaultStr, red("(Required)")+" Template's id or label"),
				"label":                      c.FlagSet.String("label", _nilDefaultStr, red("(Required)")+" Template's label"),
				"display_name":               c.FlagSet.String("display-name", _nilDefaultStr, red("(Required)")+" Template's display name"),
				"size":                       c.FlagSet.Int("size", _nilDefaultInt, "Template's size (bytes)"),
				"boot_methods_supported":     c.FlagSet.String("boot-methods-supported", _nilDefaultStr, "Template boot methods supported. Defaults to pxe_iscsi."),
				"os_bootstrap_function_name": c.FlagSet.String("os-bootstrap-function-name", _nilDefaultStr, "Optional property that selects the cloudinit configuration function. Can be one of: provisioner_os_cloudinit_prepare_centos, provisioner_os_cloudinit_prepare_rhel, provisioner_os_cloudinit_prepare_ubuntu, provisioner_os_cloudinit_prepare_windows."),
				"boot_type":                  c.FlagSet.String("boot-type", _nilDefaultStr, red("(Required)")+" Template boot type. Possible values: 'uefi_only','legacy_only' "),
				"description":                c.FlagSet.String("description", _nilDefaultStr, "Template description"),
				"os_type":                    c.FlagSet.String("os-type", _nilDefaultStr, red("(Required)")+" Template operating system type. For example, Ubuntu or CentOS."),
				"os_version":                 c.FlagSet.String("os-version", _nilDefaultStr, red("(Required)")+" Template operating system version."),
				"os_architecture":            c.FlagSet.String("os-architecture", _nilDefaultStr, red("(Required)")+" Template operating system architecture.Possible values: none, unknown, x86, x86_64."),
				"os_asset_id_bootloader_local_install_id_or_name": c.FlagSet.String("install-bootloader-asset", _nilDefaultStr, "Template's bootloader asset id during install"),
				"os_asset_id_bootloader_os_boot_id_or_name":       c.FlagSet.String("os-boot-bootloader-asset", _nilDefaultStr, "Template's bootloader asset id during regular server boot"),
				"initial_user":                       c.FlagSet.String("initial-user", _nilDefaultStr, red("(Required)")+" Template's initial username, used to verify install."),
				"initial_password":                   c.FlagSet.String("initial-password", _nilDefaultStr, red("(Required)")+" Template's initial password, used to verify install."),
				"use_autogenerated_initial_password": c.FlagSet.Bool("use-autogenerated-initial-password", false, green("(Flag)")+" If set will automatically generate a password for the template and provide it during install via the initial_password and initial_user variables. Cannot be used with --initial-password, requires --initial-user params."),
				"initial_ssh_port":                   c.FlagSet.Int("initial-ssh-port", _nilDefaultInt, red("(Required)")+" Template's initial ssh port, used to verify install."),
				"os_ready_method":                    c.FlagSet.String("os-ready-method", _nilDefaultStr, "Possible values: 'wait_for_ssh', 'wait_for_signal_from_os'. Default value: 'wait_for_ssh'."),
				"change_password_after_deploy":       c.FlagSet.Bool("change-password-after-deploy", false, "Option to change the initial_user password on the installed OS after deploy."),
				"image_build_required":               c.FlagSet.Bool("image-build-required", false, green("(Flag)")+" If set will determine the image building process building an ISO. Needed for the OOB only install process."),
				"provision_via_oob":                  c.FlagSet.Bool("provision-via-oob", false, green("(Flag)")+" If set will perform the installation process via the OOB. Always set this together with the image-build-required flag."),
				"repo_url":                           c.FlagSet.String("repo-url", _nilDefaultStr, "Template description"),
			}
		},
		ExecuteFunc: templateEditCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "Get details about a template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "get",
		AltPredicate: "show",
		FlagSet:      flag.NewFlagSet("get template", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", _nilDefaultStr, "Asset's id or name"),
				"format":              c.FlagSet.String("format", _nilDefaultStr, "The output format. Supported values are 'json','csv','yaml'. The default format is human readable."),
				"show_credentials":    c.FlagSet.Bool("show-credentials", false, green("(Flag)")+" If set returns the templates initial ssh credentials"),
			}
		},
		ExecuteFunc: templateGetCmd,
		Endpoint:    DeveloperEndpoint,
	},
	{
		Description:  "Delete a template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "delete",
		AltPredicate: "rm",
		FlagSet:      flag.NewFlagSet("delete template", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", _nilDefaultStr, "Asset's id or name"),
				"autoconfirm":         c.FlagSet.Bool("autoconfirm", false, green("(Flag)")+" If set it will assume action is confirmed"),
			}
		},
		ExecuteFunc: templateDeleteCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "Allow other users of the platform to use the OS template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "make-public",
		AltPredicate: "public",
		FlagSet:      flag.NewFlagSet("make template public", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", _nilDefaultStr, "Template id or name"),
			}
		},
		ExecuteFunc: templateMakePublicCmd,
		Endpoint:    DeveloperEndpoint,
	},
	{
		Description:  "Stop other users of the platform from being able to use the OS template by allocating a specific owner.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "make-private",
		AltPredicate: "private",
		FlagSet:      flag.NewFlagSet("make template private", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", _nilDefaultStr, "Template id or name"),
				"user_id":             c.FlagSet.String("user-id", _nilDefaultStr, "New owner user id or email."),
			}
		},
		ExecuteFunc: templateMakePrivateCmd,
		Endpoint:    DeveloperEndpoint,
	},
	{
		Description:  "List associated assets.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "list-assets",
		AltPredicate: "assoc",
		FlagSet:      flag.NewFlagSet("associated assets", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", _nilDefaultStr, "Template's id or name"),
			}
		},
		ExecuteFunc: templateListAssociatedAssetsCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "Register a template from the template repository.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "register",
		AltPredicate: "build",
		FlagSet:      flag.NewFlagSet("register template from repo", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"name":            c.FlagSet.String("name", _nilDefaultStr, red("(Required)")+"Name of the template."),
				"source-template": c.FlagSet.String("source-template", _nilDefaultStr, red("(Required)")+"The source template to use as a base. It is either the source template path from a repository or a local path to a template.yaml file."),
				"source-iso":      c.FlagSet.String("source-iso", _nilDefaultStr, red("(Required)")+"The local path for the source ISO image path."),
				"label":           c.FlagSet.String("label", _nilDefaultStr, yellow("(Optional)")+"Label of the template. If not present, is the name of the template. Using a different label name on subsequent runs will create a new template."),
				"description":     c.FlagSet.String("description", _nilDefaultStr, yellow("(Optional)")+"Description of the template."),
				"assets-update":   c.FlagSet.String("assets-update", _nilDefaultStr, yellow("(Optional)")+"Assets that will have their contents replaced inside the template. Check examples for format."),
				"repo":            c.FlagSet.String("repo", _nilDefaultStr, yellow("(Optional)")+"Override the default github url used to download template files for given OS."),
				// Add this parameter when ISO upload is allowed
				// "skip-upload-to-repo":      c.FlagSet.Bool("skip-upload-to-repo", false, yellow("(Optional)")+"Skip ISO image upload to the HTTP repository."),
				"strict-host-key-checking": c.FlagSet.Bool("strict-host-key-checking", true, yellow("(Optional)")+"Skip the manual check when adding a host key to the known_hosts file in the ISO image upload process."),
				"replace-if-exists":        c.FlagSet.Bool("replace-if-exists", false, yellow("(Optional)")+"Replaces ISO image if one already exists in the HTTP repository."),
				"debug":                    c.FlagSet.Bool("debug", false, green("(Flag)")+"If set, increases log level."),
				"return-id":                c.FlagSet.Bool("return-id", false, green("(Flag)")+"If set, returns the ID of the generated template. Useful for automation."),
			}
		},
		ExecuteFunc: templateRegisterCmd,
		Endpoint:    ExtendedEndpoint,
		Example: `
		metalcloud-cli os-template register --name test-template --source-template Ubuntu/20.04/oob-uefi-boot --source-iso ubuntu-20.04.4-live-server-amd64.iso —-assets-update user-data:./replace_asset_1,vendor-data:./replace_asset_2
		metalcloud-cli os-template register --name test-100 --source-template Ubuntu/20.04/oob-uefi-boot --source-iso ubuntu-20.04.4-live-server-amd64.iso --replace-if-exists --strict-host-key-checking=false
	`,
	},
	{
		Description:  "Create a diff file.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "create-diff",
		AltPredicate: "diff",
		FlagSet:      flag.NewFlagSet("create the diff of 2 files", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"file1":       c.FlagSet.String("file1", _nilDefaultStr, red("(Required)")+"Path of the first file."),
				"file2":       c.FlagSet.String("file2", _nilDefaultStr, red("(Required)")+"Path of the second file."),
				"output-file": c.FlagSet.String("output-file", _nilDefaultStr, red("(Required)")+"Path of the output file. This file must have Unix(LF) end of line encoding to be used as a patch file later."),
			}
		},
		ExecuteFunc: templateDiffCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "List OS source templates from a repository.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "list-source-templates",
		AltPredicate: "source-templates",
		FlagSet:      flag.NewFlagSet("list OS source templates from a repository", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"repo":   c.FlagSet.String("repo", _nilDefaultStr, yellow("(Optional)")+"Override the default github url used to download template files for given OS."),
				"format": c.FlagSet.String("format", _nilDefaultStr, "The output format. Supported values are 'json','csv','yaml'. The default format is human readable."),
			}
		},
		ExecuteFunc: templateListRepoCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "List the assets from an OS source template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "list-source-template-assets",
		AltPredicate: "source-template-assets",
		FlagSet:      flag.NewFlagSet("list assets from an OS source template", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"repo":            c.FlagSet.String("repo", _nilDefaultStr, yellow("(Optional)")+"Override the default github url used to download template files for given OS. If using a local template, use the keyword 'local'."),
				"source-template": c.FlagSet.String("source-template", _nilDefaultStr, red("(Required)")+"The source template to use as a base. It's either the source path from a repository or a local path to the template.yaml file."),
				"format":          c.FlagSet.String("format", _nilDefaultStr, "The output format. Supported values are 'json','csv','yaml'. The default format is human readable."),
			}
		},
		ExecuteFunc: templateListAssetsCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "Validates OS source templates from a repository.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "validate-repo",
		AltPredicate: "validate-repo",
		FlagSet:      flag.NewFlagSet("validate OS source templates from a repository", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"repo": c.FlagSet.String("repo", _nilDefaultStr, yellow("(Optional)")+"Override the default github url used to download template files for given OS."),
			}
		},
		ExecuteFunc: templateValidateRepoCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "Validates an OS source template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "validate-template",
		AltPredicate: "validate-template",
		FlagSet:      flag.NewFlagSet("validate an OS source templates", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"repo":            c.FlagSet.String("repo", _nilDefaultStr, yellow("(Optional)")+"Override the default github url used to download template files for given OS. If using a local template, use the keyword 'local'."),
				"source-template": c.FlagSet.String("source-template", _nilDefaultStr, red("(Required)")+"The source template to use as a base. It's either the source path from a repository or a local path to the template.yaml file."),
			}
		},
		ExecuteFunc: templateValidateCmd,
		Endpoint:    ExtendedEndpoint,
	},
}

func templatesListCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {

	list, err := client.OSTemplates()

	if err != nil {
		return "", err
	}

	schema := []tableformatter.SchemaField{
		{
			FieldName: "ID",
			FieldType: tableformatter.TypeInt,
			FieldSize: 2,
		},
		{
			FieldName: "LABEL",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "NAME",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "DESCRIPTION",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "SIZE_MBYTES",
			FieldType: tableformatter.TypeInt,
			FieldSize: 5,
		},
		{
			FieldName: "BOOT_METHODS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "OS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "INSTALL_BOOTLOADER",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "OS_BOOTLOADER",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "USER_ID",
			FieldType: tableformatter.TypeInt,
			FieldSize: 5,
		},
		{
			FieldName: "CREATED",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "UPDATED",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
	}

	data := [][]interface{}{}
	for _, s := range *list {

		installBootloader := ""
		if s.OSAssetBootloaderLocalInstall != 0 {
			asset, err := client.OSAssetGet(s.OSAssetBootloaderLocalInstall)
			if err != nil {
				return "", err
			}
			installBootloader = asset.OSAssetFileName
		}
		osBootloader := ""
		if s.OSAssetBootloaderOSBoot != 0 {
			asset, err := client.OSAssetGet(s.OSAssetBootloaderOSBoot)
			if err != nil {
				return "", err
			}
			osBootloader = asset.OSAssetFileName
		}

		osData := ""

		if s.VolumeTemplateOperatingSystem != nil {
			os := *s.VolumeTemplateOperatingSystem
			osData = fmt.Sprintf("%s %s %s",
				os.OperatingSystemType,
				os.OperatingSystemVersion,
				os.OperatingSystemArchitecture)
		}

		data = append(data, []interface{}{
			s.VolumeTemplateID,
			s.VolumeTemplateLabel,
			s.VolumeTemplateDisplayName,
			s.VolumeTemplateDescription,
			s.VolumeTemplateSizeMBytes,
			s.VolumeTemplateBootMethodsSupported,
			osData,
			installBootloader,
			osBootloader,
			s.UserID,
			s.VolumeTemplateCreatedTimestamp,
			s.VolumeTemplateUpdatedTimestamp,
		})

	}

	tableformatter.TableSorter(schema).OrderBy(schema[0].FieldName).Sort(data)

	table := tableformatter.Table{
		Data:   data,
		Schema: schema,
	}
	return table.RenderTable("Templates", "", getStringParam(c.Arguments["format"]))
}

func templateCreateCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {
	obj := metalcloud.OSTemplate{}
	updatedObj, err := updateTemplateFromCommand(obj, c, client, true)
	if err != nil {
		return "", err
	}

	ret, err := client.OSTemplateCreate(*updatedObj)
	if err != nil {
		return "", err
	}

	if getBoolParam(c.Arguments["return-id"]) {
		return fmt.Sprintf("%d", ret.VolumeTemplateID), nil
	}

	return "", err
}

func templateEditCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {

	obj, err := getOSTemplateFromCommand("id", c, client, false)
	if err != nil {
		return "", err
	}
	newobj := metalcloud.OSTemplate{}
	updatedObj, err := updateTemplateFromCommand(newobj, c, client, false)
	if err != nil {
		return "", err
	}

	_, err = client.OSTemplateUpdate(obj.VolumeTemplateID, *updatedObj)

	return "", err
}

func updateTemplateFromCommand(obj metalcloud.OSTemplate, c *Command, client metalcloud.MetalCloudClient, checkRequired bool) (*metalcloud.OSTemplate, error) {
	if v, ok := getStringParamOk(c.Arguments["version"]); ok {
		obj.VolumeTemplateVersion = v
	}

	if v, ok := getStringParamOk(c.Arguments["os_ready_method"]); ok {
		obj.VolumeTemplateOSReadyMethod = v
	}

	if v, ok := getStringParamOk(c.Arguments["os_bootstrap_function_name"]); ok {
		obj.VolumeTemplateOsBootstrapFunctionName = v
	}

	if v, ok := getStringParamOk(c.Arguments["label"]); ok {
		obj.VolumeTemplateLabel = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("label is required")
		}
	}

	if v, ok := getStringParamOk(c.Arguments["display_name"]); ok {
		obj.VolumeTemplateDisplayName = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("display-name is required")
		}
	}

	if v, ok := getIntParamOk(c.Arguments["size"]); ok {
		obj.VolumeTemplateSizeMBytes = v
	}

	obj.VolumeTemplateIsOSTemplate = true

	if v, ok := getStringParamOk(c.Arguments["boot_methods_supported"]); ok {
		obj.VolumeTemplateBootMethodsSupported = v
	}

	if v, ok := getStringParamOk(c.Arguments["boot_type"]); ok {
		obj.VolumeTemplateBootType = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("boot-type is required")
		}
	}

	if v, ok := getStringParamOk(c.Arguments["description"]); ok {
		obj.VolumeTemplateDescription = v
	}

	//OS Data
	os, err := getOperatingSystemFromCommand(c)

	if err != nil {
		return nil, err
	} else if checkRequired && *os == (metalcloud.OperatingSystem{}) {
		return nil, fmt.Errorf("os flags are required")
	}
	if *os != (metalcloud.OperatingSystem{}) {
		obj.VolumeTemplateOperatingSystem = os
	}

	//Network OS Data
	nos, err := getNetworkOperatingSystemFromCommand(c)

	if err != nil {
		return nil, err
	}
	if *nos != (metalcloud.NetworkOperatingSystem{}) {
		obj.VolumeTemplateNetworkOperatingSystem = nos
	}

	// Boot options

	if _, ok := getStringParamOk(c.Arguments["os_asset_id_bootloader_local_install_id_or_name"]); ok {
		localInstallAsset, err := getOSAssetFromCommand("install_bootloader_asset", "os_asset_id_bootloader_local_install_id_or_name", c, client)
		if err != nil {
			return nil, err
		}
		obj.OSAssetBootloaderLocalInstall = localInstallAsset.OSAssetID
	}

	if _, ok := getStringParamOk(c.Arguments["os_asset_id_bootloader_os_boot_id_or_name"]); ok {
		osBootBootloaderAsset, err := getOSAssetFromCommand("os_boot_bootloader_asset", "os_asset_id_bootloader_os_boot_id_or_name", c, client)
		if err != nil {
			return nil, err
		}
		obj.OSAssetBootloaderOSBoot = osBootBootloaderAsset.OSAssetID
	}

	//Credentials

	creds, err := getCredentialsFromCommand(c, checkRequired)

	if err != nil {
		return nil, err
	}

	if *creds != (metalcloud.OSTemplateCredentials{}) {
		obj.OSTemplateCredentials = creds
	}

	if v, ok := getStringParamOk(c.Arguments["repo_url"]); ok {
		obj.VolumeTemplateRepoURL = v
	}

	obj.VolumeTemplateImageBuildRequired = getBoolParam(c.Arguments["image_build_required"])
	obj.VolumeTemplateProvisionViaOOB = getBoolParam(c.Arguments["provision_via_oob"])

	return &obj, nil
}

func getCredentialsFromCommand(c *Command, checkRequired bool) (*metalcloud.OSTemplateCredentials, error) {
	var creds = metalcloud.OSTemplateCredentials{}

	if getBoolParam(c.Arguments["use_autogenerated_initial_password"]) {

		creds.OSTemplateUseAutogeneratedInitialPassword = true

		if _, ok := getStringParamOk(c.Arguments["initial_password"]); ok {
			return nil, fmt.Errorf("--initial-password cannot be used with --use-autogenerated-initial-password")
		}

	} else {

		if v, ok := getStringParamOk(c.Arguments["initial_password"]); ok {
			creds.OSTemplateInitialPassword = v
		} else {
			if checkRequired {
				return nil, fmt.Errorf("either --initial-password or --use-autogenerated-initial-password is required")
			}
		}
	}

	if v, ok := getStringParamOk(c.Arguments["initial_user"]); ok {

		creds.OSTemplateInitialUser = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("initial-user is required")
		}
	}

	if v, ok := getIntParamOk(c.Arguments["initial_ssh_port"]); ok {
		creds.OSTemplateInitialSSHPort = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("initial-ssh-port is required")
		}
	}

	creds.OSTemplateChangePasswordAfterDeploy = getBoolParam(c.Arguments["change_password_after_deploy"])

	return &creds, nil
}

func templateDeleteCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {

	retS, err := getOSTemplateFromCommand("id", c, client, false)
	if err != nil {
		return "", err
	}
	confirm := false

	if getBoolParam(c.Arguments["autoconfirm"]) {
		confirm = true
	} else {

		confirmationMessage := fmt.Sprintf("Deleting template %s (%d).  Are you sure? Type \"yes\" to continue:",
			retS.VolumeTemplateDisplayName,
			retS.VolumeTemplateID)

		//this is simply so that we don't output a text on the command line under go test
		if strings.HasSuffix(os.Args[0], ".test") {
			confirmationMessage = ""
		}

		confirm, err = requestConfirmation(confirmationMessage)
		if err != nil {
			return "", err
		}

	}

	if !confirm {
		return "", fmt.Errorf("Operation not confirmed. Aborting")
	}

	err = client.OSTemplateDelete(retS.VolumeTemplateID)

	return "", err
}

func templateGetCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {

	showCredentials := false
	if c.Arguments["show_credentials"] != nil && *c.Arguments["show_credentials"].(*bool) {
		showCredentials = true
	}

	template, err := getOSTemplateFromCommand("id", c, client, showCredentials)
	if err != nil {
		return "", err
	}

	if err != nil {
		return "", err
	}

	schema := []tableformatter.SchemaField{
		{
			FieldName: "ID",
			FieldType: tableformatter.TypeInt,
			FieldSize: 2,
		},
		{
			FieldName: "LABEL",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "NAME",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "DESCRIPTION",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "SIZE_MBYTES",
			FieldType: tableformatter.TypeInt,
			FieldSize: 5,
		},
		{
			FieldName: "BOOT_METHODS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "OS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "USER_ID",
			FieldType: tableformatter.TypeInt,
			FieldSize: 5,
		},
		{
			FieldName: "INSTALL_BOOTLOADER",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "OS_BOOTLOADER",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "CREATED",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "UPDATED",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
	}

	data := [][]interface{}{}

	credentials := ""

	if showCredentials && template.OSTemplateCredentials != nil {

		schema = append(schema, tableformatter.SchemaField{
			FieldName: "CREDENTIALS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		})

		credentials = fmt.Sprintf("user:%s (port %d) passwd:%s (change_password_after_install:%v)",
			template.OSTemplateCredentials.OSTemplateInitialUser,
			template.OSTemplateCredentials.OSTemplateInitialSSHPort,
			template.OSTemplateCredentials.OSTemplateInitialPassword,
			template.OSTemplateCredentials.OSTemplateChangePasswordAfterDeploy)

	}
	osDetails := ""

	if template.VolumeTemplateOperatingSystem != nil {
		os := *template.VolumeTemplateOperatingSystem
		osDetails = fmt.Sprintf("%s %s %s",
			os.OperatingSystemType,
			os.OperatingSystemVersion,
			os.OperatingSystemArchitecture)
	}

	installBootloader := ""
	if template.OSAssetBootloaderLocalInstall != 0 {
		asset, err := client.OSAssetGet(template.OSAssetBootloaderLocalInstall)
		if err != nil {
			return "", err
		}
		installBootloader = asset.OSAssetFileName
	}
	osBootloader := ""
	if template.OSAssetBootloaderOSBoot != 0 {
		asset, err := client.OSAssetGet(template.OSAssetBootloaderOSBoot)
		if err != nil {
			return "", err
		}
		osBootloader = asset.OSAssetFileName
	}

	data = append(data, []interface{}{
		template.VolumeTemplateID,
		template.VolumeTemplateLabel,
		template.VolumeTemplateDisplayName,
		template.VolumeTemplateDescription,
		template.VolumeTemplateSizeMBytes,
		template.VolumeTemplateBootMethodsSupported,
		osDetails,
		template.UserID,
		installBootloader,
		osBootloader,
		template.VolumeTemplateCreatedTimestamp,
		template.VolumeTemplateUpdatedTimestamp,
		credentials,
	})

	topLine := fmt.Sprintf("Template %s (%d)\n", template.VolumeTemplateLabel, template.VolumeTemplateID)

	tableformatter.TableSorter(schema).OrderBy(
		schema[0].FieldName,
		schema[1].FieldName).Sort(data)

	table := tableformatter.Table{
		Data:   data,
		Schema: schema,
	}
	return table.RenderTable("Templates", topLine, getStringParam(c.Arguments["format"]))
}

func templateMakePublicCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {
	template, err := getOSTemplateFromCommand("id", c, client, false)

	if err != nil {
		return "", err
	}

	err = client.OSTemplateMakePublic(template.VolumeTemplateID)

	if err != nil {
		return "", err
	}

	return "", nil
}

func templateMakePrivateCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {
	template, err := getOSTemplateFromCommand("id", c, client, false)

	if err != nil {
		return "", err
	}

	user, err := getUserFromCommand("user-id", c, client)

	if err != nil {
		return "", err
	}

	if err = client.OSTemplateMakePrivate(template.VolumeTemplateID, user.UserID); err != nil {
		return "", err
	}

	return "", nil
}

func templateRegisterCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {
	var sourceTemplate string

	if sourceTemplateValue, ok := getStringParamOk(c.Arguments["source-template"]); !ok {
		return "", fmt.Errorf("The 'source-template' parameter must be specified when using the 'build' command.")
	} else {
		sourceTemplate = sourceTemplateValue
	}

	useLocalTemplate := false

	if repoValue, ok := getStringParamOk(c.Arguments["repo"]); ok {
		if repoValue == localRepositoryName {
			useLocalTemplate = true
		}
	}

	var repoTemplate RepoTemplate

	if !useLocalTemplate {
		repoMap := make(map[string]RepoTemplate)
		err := retrieveRepositoryAssets(c, repoMap)

		if err != nil {
			return "", err
		}

		if _, ok := repoMap[sourceTemplate]; !ok {
			return "", fmt.Errorf("Did not find source template '%s' in the repository.", sourceTemplate)
		}

		repoTemplate = repoMap[sourceTemplate]
	} else {
		fmt.Printf("Did not find source template '%s' in the repository, checking for local file.\n", sourceTemplate)

		_, err := os.ReadFile(sourceTemplate)

		if err != nil {
			return "", fmt.Errorf("Template file not found at path %s.", sourceTemplate)
		}

		getLocalTemplateAssets(filepath.Dir(sourceTemplate), &repoTemplate)
		_, err = populateTemplateValues(&repoTemplate)

		if err != nil {
			return "", err
		}
	}

	if len(repoTemplate.Errors) != 0 {
		fmt.Printf("Detected the following errors regarding template structure for template %s:\n", sourceTemplate)
	} else {
		fmt.Printf("Detected no errors for the given template.\n")
	}

	for _, errorMessage := range repoTemplate.Errors {
		fmt.Println("\t" + errorMessage)
	}

	if len(repoTemplate.Errors) != 0 {
		return "", fmt.Errorf("Aborting build due to errors regarding the source template.\n")
	}

	templateLabel, err := handleTemplateBuild(c, client, repoTemplate)

	if err != nil {
		return "", err
	}

	var templateID int
	var template metalcloud.OSTemplate

	list, err := client.OSTemplates()

	if err != nil {
		return "", err
	}

	for _, s := range *list {
		if s.VolumeTemplateLabel == templateLabel {
			template = s
			templateID = s.VolumeTemplateID
			break
		}
	}

	if !repoTemplate.OsTemplateContents.ProvisionViaOob {
		if repoTemplate.OsTemplateContents.InstallBootloaderAsset != "" || repoTemplate.OsTemplateContents.OsBootBootloaderAsset != "" {
			list, err := client.OSTemplateOSAssets(templateID)

			if err != nil {
				return "", err
			}

			for _, a := range *list {
				if a.OSAsset.OSAssetFileName == repoTemplate.OsTemplateContents.InstallBootloaderAsset {
					template.OSAssetBootloaderLocalInstall = a.OSAsset.OSAssetID
				} else if a.OSAsset.OSAssetFileName == repoTemplate.OsTemplateContents.OsBootBootloaderAsset {
					template.OSAssetBootloaderOSBoot = a.OSAsset.OSAssetID
				}
			}
			_, err = client.OSTemplateUpdate(templateID, template)

			if err != nil {
				return "", err
			}
		}
	}

	if err != nil {
		return "", fmt.Errorf("Failed to create template. Received error: %s", err)
	} else {
		fmt.Println("Done.")
	}

	if getBoolParam(c.Arguments["return-id"]) {
		return fmt.Sprintf("%d", templateID), nil
	}

	return "", nil
}

func retrieveRepositoryAssets(c *Command, repoMap map[string]RepoTemplate) error {
	cloneOptions := new(git.CloneOptions)
	cloneOptions.Depth = 1 // We are only interested in the last commit

	if repositoryName, ok := getStringParamOk(c.Arguments["repo"]); ok {
		var username, password string

		if userPrivateUsername := os.Getenv("METALCLOUD_USER_PRIVATE_REPOSITORY_USERNAME"); userPrivateUsername != "" {
			username = userPrivateUsername
		}

		if userPrivateToken := os.Getenv("METALCLOUD_USER_PRIVATE_REPOSITORY_TOKEN"); userPrivateToken != "" {
			password = userPrivateToken
		}

		cloneOptions.Auth = &http.BasicAuth{
			Username: username,
			Password: password,
		}

		cloneOptions.URL = repositoryName
	} else {
		// The default repository that is used if the user doesn't specify another one
		cloneOptions.URL = "https://github.com/metalsoft-io/os-templates.git"
	}

	// Filesystem abstraction based on memory
	fs := memfs.New()

	// Git objects storer based on memory
	storer := memory.NewStorage()

	// Clones the repository into the worktree (fs) and storer all the .git
	// content into the storer
	repo, err := git.Clone(storer, fs, cloneOptions)

	if err != nil {
		if err.Error() == "authentication required" {
			return fmt.Errorf("Failed to authenticate to the given repository. Please check if the repository exists and/or the given username is valid in the METALCLOUD_USER_PRIVATE_REPOSITORY_USERNAME environment variable and the given access token is valid in the METALCLOUD_USER_PRIVATE_REPOSITORY_TOKEN environment variable.")
		}

		return err
	}

	// Retrieve the HEAD reference
	ref, err := repo.Head()

	if err != nil {
		return err
	}

	commit, err := repo.CommitObject(ref.Hash())

	if err != nil {
		return err
	}

	tree, err := commit.Tree()

	if err != nil {
		return err
	}

	// This map stores all files for a template and will be used to check if their information is correct
	repoAssetsPerTemplate := make(map[string][]TemplateAsset)

	getRepositoryTemplateAssets(tree, repoMap, repoAssetsPerTemplate)
	repoHasErrors := false

	for templatePreffix, repoTemplate := range repoMap {
		repoTemplate.Assets = make(map[string]TemplateAsset)
		for _, asset := range repoAssetsPerTemplate[templatePreffix] {
			repoTemplate.Assets[asset.name] = asset
		}

		repoHasErrors, err = populateTemplateValues(&repoTemplate)

		if err != nil {
			return err
		}

		repoMap[templatePreffix] = repoTemplate
	}

	if repoHasErrors {
		fmt.Printf("Found errors for repository %s! Use the 'validate-repo' function to see them and fix them.\n", cloneOptions.URL)
	}

	return nil
}

func createRepositoryTemplatesTable(repoMap map[string]RepoTemplate) tableformatter.Table {
	schema := []tableformatter.SchemaField{
		{
			FieldName: "TYPE",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "VERSION",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "ARCHITECTURE",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "DEPLOY PROCESS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "BOOT TYPE",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "SOURCE TEMPLATE PATH",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
	}

	data := [][]interface{}{}
	for templatePreffix, repoTemplate := range repoMap {
		var architecture, deployProcess, bootType, version string

		switch repoTemplate.Architecture {
		case osArchitecture64:
			architecture = "x64"
		default:
			architecture = red("unknown")
		}

		switch repoTemplate.DeployProcess {
		case bootMethodLocalDrives:
			deployProcess = "virtual_media"
		case bootMethodPxeIscsi:
			deployProcess = "pxe"
		default:
			deployProcess = red("unknown")
		}

		switch repoTemplate.BootType {
		case bootTypeUEFIOnly:
			bootType = "UEFI"
		case bootTypeLegacyOnly:
			bootType = "Legacy"
		default:
			bootType = red("unknown")
		}

		if repoTemplate.Version == "" {
			version = red("unknown")
		} else {
			version = repoTemplate.Version
		}

		data = append(data, []interface{}{
			repoTemplate.Type,
			version,
			architecture,
			deployProcess,
			bootType,
			templatePreffix,
		})

	}

	tableformatter.TableSorter(schema).OrderBy(schema[0].FieldName).Sort(data)

	table := tableformatter.Table{
		Data:   data,
		Schema: schema,
	}

	return table
}

func createTemplateAssetsTable(repoTemplate RepoTemplate) tableformatter.Table {
	schema := []tableformatter.SchemaField{
		{
			FieldName: "ASSET NAME",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "ISO_PATH",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "MIME",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "USAGE",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "TYPE",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "URL",
			FieldType: tableformatter.TypeString,
			FieldSize: 10,
		},
		{
			FieldName: "PATH",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
	}

	data := [][]interface{}{}
	for _, asset := range repoTemplate.Assets {
		data = append(data, []interface{}{
			asset.name,
			asset.Isopath,
			asset.Mime,
			asset.Usage,
			asset.Type,
			asset.Url,
			asset.Path,
		})

	}

	tableformatter.TableSorter(schema).OrderBy(schema[0].FieldName).Sort(data)

	table := tableformatter.Table{
		Data:   data,
		Schema: schema,
	}

	return table
}

func handleTemplateBuild(c *Command, client metalcloud.MetalCloudClient, repoTemplate RepoTemplate) (string, error) {
	if templateName, ok := getStringParamOk(c.Arguments["name"]); ok {
		// ISO images are required only for the OOB templates and the patch files are only applied to the bootloader file retrieved from the ISO image.
		err := checkOOBTemplateIntegrity(c, repoTemplate)

		if err != nil {
			return "", err
		}

		templateLabel, err := createTemplateAssets(c, client, repoTemplate, templateName)

		if err != nil {
			return "", err
		}

		return templateLabel, nil
	} else {
		return "", fmt.Errorf("The 'name' parameter must be specified when using the 'build' command.")
	}
}

func checkOOBTemplateIntegrity(c *Command, repoTemplate RepoTemplate) error {
	if !repoTemplate.OsTemplateContents.ProvisionViaOob {
		return nil
	}

	var imagePath string

	if sourceISO, ok := getStringParamOk(c.Arguments["source-iso"]); ok {
		imagePath = sourceISO
	} else {
		return fmt.Errorf("The 'source-iso' parameter must be specified with the 'name' and 'source-template' ones for OOB templates.")
	}

	file, err := os.Open(imagePath)

	if err != nil {
		return fmt.Errorf("Image not found at path %s.", imagePath)
	}
	defer file.Close()

	image, err := iso9660.OpenImage(file)

	if err != nil {
		return err
	}

	rootDir, err := image.RootDir()

	if err != nil {
		return err
	}

	children, err := rootDir.GetChildren()

	if err != nil {
		return err
	}

	var bootloaderFile *iso9660.File = nil

	for _, asset := range repoTemplate.Assets {
		if asset.Type != assetTypePatch {
			continue
		}

		for _, child := range children {
			if !child.IsDir() && child.Name() == asset.name {
				bootloaderFile = child
				break
			}
		}

		if bootloaderFile == nil {
			return fmt.Errorf("Could not apply patch asset as the bootloader config file with name '%s' was not found in the given ISO image.", asset.name)
		}

		bootloaderData, err := ioutil.ReadAll(bootloaderFile.Reader())

		if err != nil {
			return err
		}

		patchFileStringContents := asset.contents

		diffMatchPatch := diff.New()

		patches, err := diffMatchPatch.PatchFromText(patchFileStringContents)

		if err != nil {
			return fmt.Errorf("Failed to apply patch for asset %s. Make sure the file has a Unix (LF) End Of Line sequence.", asset.name)
		}

		patchedText, _ := diffMatchPatch.PatchApply(patches, string(bootloaderData))

		//Remove tabs and blank lines, somehow they get added when applying the patch
		patchedText = strings.ReplaceAll(patchedText, "\t", "")
		patchedText = strings.TrimSpace(patchedText)
		asset.contents = string(patchedText)

		repoTemplate.Assets[asset.name] = asset
	}

	return nil
}

func createTemplateAssets(c *Command, client metalcloud.MetalCloudClient, repoTemplate RepoTemplate, templateName string) (string, error) {
	OsTemplateContents := repoTemplate.OsTemplateContents

	createTemplateCommand := Command{
		Description:  "Create a template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "create",
		AltPredicate: "new",
		FlagSet:      flag.NewFlagSet("create template", flag.ExitOnError),
		ExecuteFunc:  templateCreateCmd,
		Endpoint:     ExtendedEndpoint,
	}

	templateLabel, err := makeLabel(templateName)
	if err != nil {
		return "", err
	}

	templateDescription := _nilDefaultStr

	if label, ok := getStringParamOk(c.Arguments["label"]); ok {
		templateLabel = label
	}

	if description, ok := getStringParamOk(c.Arguments["description"]); ok {
		templateDescription = description
	}

	createTemplateCommand.Arguments = map[string]interface{}{
		"label":                              createTemplateCommand.FlagSet.String("label", templateLabel, red("(Required)")+" Template's label"),
		"display_name":                       createTemplateCommand.FlagSet.String("display-name", templateName, red("(Required)")+" Template's display name"),
		"size":                               createTemplateCommand.FlagSet.Int("size", _nilDefaultInt, "Template's size (bytes)"),
		"boot_methods_supported":             createTemplateCommand.FlagSet.String("boot-methods-supported", OsTemplateContents.BootMethodsSupported, red("(Required)")+" Template boot methods supported. Defaults to pxe_iscsi."),
		"os_bootstrap_function_name":         createTemplateCommand.FlagSet.String("os-bootstrap-function-name", _nilDefaultStr, "Optional property that selects the cloudinit configuration function. Can be one of: provisioner_os_cloudinit_prepare_centos, provisioner_os_cloudinit_prepare_rhel, provisioner_os_cloudinit_prepare_ubuntu, provisioner_os_cloudinit_prepare_windows."),
		"boot_type":                          createTemplateCommand.FlagSet.String("boot-type", OsTemplateContents.BootType, red("(Required)")+" Template boot type. Possible values: 'uefi_only','legacy_only' "),
		"description":                        createTemplateCommand.FlagSet.String("description", templateDescription, "Template description"),
		"os_type":                            createTemplateCommand.FlagSet.String("os-type", repoTemplate.Type, red("(Required)")+" Template operating system type. For example, Ubuntu or CentOS."),
		"os_version":                         createTemplateCommand.FlagSet.String("os-version", repoTemplate.Version, red("(Required)")+" Template operating system version."),
		"os_architecture":                    createTemplateCommand.FlagSet.String("os-architecture", repoTemplate.Architecture, red("(Required)")+" Template operating system architecture.Possible values: none, unknown, x86, x86_64."),
		"initial_user":                       createTemplateCommand.FlagSet.String("initial-user", OsTemplateContents.InitialUser, red("(Required)")+" Template's initial username, used to verify install."),
		"initial_password":                   createTemplateCommand.FlagSet.String("initial-password", _nilDefaultStr, red("(Required)")+" Template's initial password, used to verify install."),
		"use_autogenerated_initial_password": createTemplateCommand.FlagSet.Bool("use-autogenerated-initial-password", OsTemplateContents.UseAutogeneratedInitialPassword, green("(Flag)")+" If set will automatically generate a password for the template and provide it during install via the initial_password and initial_user variables. Cannot be used withinitial-password and initial-user params."),
		"initial_ssh_port":                   createTemplateCommand.FlagSet.Int("initial-ssh-port", OsTemplateContents.InitialSSHPort, red("(Required)")+" Template's initial ssh port, used to verify install."),
		"change_password_after_deploy":       createTemplateCommand.FlagSet.Bool("change-password-after-deploy", false, "Option to change the initial_user password on the installed OS after deploy."),
		"image_build_required":               createTemplateCommand.FlagSet.Bool("image-build-required", OsTemplateContents.ImageBuildRequired, green("(Flag)")+" If set will determine the image building process building an ISO. Needed for the OOB only install process."),
		"provision_via_oob":                  createTemplateCommand.FlagSet.Bool("provision-via-oob", OsTemplateContents.ProvisionViaOob, green("(Flag)")+" If set will perform the installation process via the OOB. Always set this together with the image-build-required flag."),
		"repo_url":                           createTemplateCommand.FlagSet.String("repo-url", _nilDefaultStr, "Template's location the repository"),
		"os_ready_method":                    createTemplateCommand.FlagSet.String("os-ready-method", OsTemplateContents.OsReadyMethod, "Possible values: 'wait_for_ssh', 'wait_for_signal_from_os'. Default value: 'wait_for_ssh'."),
		"os_asset_id_bootloader_local_install_id_or_name": createTemplateCommand.FlagSet.String("install-bootloader-asset", _nilDefaultStr, "Template's bootloader asset id during install"),
		"os_asset_id_bootloader_os_boot_id_or_name":       createTemplateCommand.FlagSet.String("os-boot-bootloader-asset", _nilDefaultStr, "Template's bootloader asset id during regular server boot"),
		"version": createTemplateCommand.FlagSet.String("version", _nilDefaultStr, "Template version. Default value is 0.0.0"),
	}

	_, createError := templateCreateCmd(&createTemplateCommand, client)

	if createError != nil {
		updateTemplateCommand := Command{
			Description:  "Edit a template.",
			Subject:      "os-template",
			AltSubject:   "template",
			Predicate:    "update",
			AltPredicate: "edit",
			FlagSet:      flag.NewFlagSet("update template", flag.ExitOnError),
			ExecuteFunc:  templateEditCmd,
			Endpoint:     ExtendedEndpoint,
		}

		updateTemplateCommand.Arguments = map[string]interface{}{
			"template_id_or_name":                updateTemplateCommand.FlagSet.String("id", templateLabel, red("(Required)")+" Template's id or label"),
			"label":                              updateTemplateCommand.FlagSet.String("label", templateLabel, red("(Required)")+" Template's label"),
			"display_name":                       updateTemplateCommand.FlagSet.String("display-name", templateName, red("(Required)")+" Template's display name"),
			"size":                               updateTemplateCommand.FlagSet.Int("size", _nilDefaultInt, "Template's size (bytes)"),
			"boot_methods_supported":             updateTemplateCommand.FlagSet.String("boot-methods-supported", OsTemplateContents.BootMethodsSupported, red("(Required)")+" Template boot methods supported. Defaults to pxe_iscsi."),
			"os_bootstrap_function_name":         updateTemplateCommand.FlagSet.String("os-bootstrap-function-name", _nilDefaultStr, "Optional property that selects the cloudinit configuration function. Can be one of: provisioner_os_cloudinit_prepare_centos, provisioner_os_cloudinit_prepare_rhel, provisioner_os_cloudinit_prepare_ubuntu, provisioner_os_cloudinit_prepare_windows."),
			"boot_type":                          updateTemplateCommand.FlagSet.String("boot-type", OsTemplateContents.BootType, red("(Required)")+" Template boot type. Possible values: 'uefi_only','legacy_only' "),
			"description":                        updateTemplateCommand.FlagSet.String("description", templateDescription, "Template description"),
			"os_type":                            updateTemplateCommand.FlagSet.String("os-type", repoTemplate.Type, red("(Required)")+" Template operating system type. For example, Ubuntu or CentOS."),
			"os_version":                         updateTemplateCommand.FlagSet.String("os-version", repoTemplate.Version, red("(Required)")+" Template operating system version."),
			"os_architecture":                    updateTemplateCommand.FlagSet.String("os-architecture", repoTemplate.Architecture, red("(Required)")+" Template operating system architecture.Possible values: none, unknown, x86, x86_64."),
			"initial_user":                       updateTemplateCommand.FlagSet.String("initial-user", OsTemplateContents.InitialUser, red("(Required)")+" Template's initial username, used to verify install."),
			"initial_password":                   updateTemplateCommand.FlagSet.String("initial-password", _nilDefaultStr, red("(Required)")+" Template's initial password, used to verify install."),
			"use_autogenerated_initial_password": updateTemplateCommand.FlagSet.Bool("use-autogenerated-initial-password", OsTemplateContents.UseAutogeneratedInitialPassword, green("(Flag)")+" If set will automatically generate a password for the template and provide it during install via the initial_password and initial_user variables. Cannot be used withinitial-password and initial-user params."),
			"initial_ssh_port":                   updateTemplateCommand.FlagSet.Int("initial-ssh-port", OsTemplateContents.InitialSSHPort, red("(Required)")+" Template's initial ssh port, used to verify install."),
			"change_password_after_deploy":       updateTemplateCommand.FlagSet.Bool("change-password-after-deploy", false, "Option to change the initial_user password on the installed OS after deploy."),
			"image_build_required":               updateTemplateCommand.FlagSet.Bool("image-build-required", OsTemplateContents.ImageBuildRequired, green("(Flag)")+" If set will determine the image building process building an ISO. Needed for the OOB only install process."),
			"provision_via_oob":                  updateTemplateCommand.FlagSet.Bool("provision-via-oob", OsTemplateContents.ProvisionViaOob, green("(Flag)")+" If set will perform the installation process via the OOB. Always set this together with the image-build-required flag."),
			"repo_url":                           updateTemplateCommand.FlagSet.String("repo-url", _nilDefaultStr, "Template's location the repository"),
		}

		_, updateError := templateEditCmd(&updateTemplateCommand, client)

		if updateError != nil {
			return "", updateError
		}

		list, err := client.OSTemplates()

		if err != nil {
			return "", err
		}

		templateFound := false

		for _, s := range *list {
			if s.VolumeTemplateLabel == templateLabel {
				templateFound = true
				break
			}
		}

		if !templateFound {
			return "", createError
		}
	}

	createAssetCommand := Command{
		Description:  "Create asset.",
		Subject:      "asset",
		AltSubject:   "asset",
		Predicate:    "create",
		AltPredicate: "new",
		ExecuteFunc:  assetCreateCmd,
		Endpoint:     DeveloperEndpoint,
	}

	assets := []Asset{}

	err = createIsoImageAsset(c, repoTemplate, &assets, templateName, templateLabel, createAssetCommand)

	if err != nil {
		return "", err
	}

	err = createOtherAssets(c, repoTemplate, &assets, templateName, templateLabel, createAssetCommand)

	if err != nil {
		return "", err
	}

	for _, asset := range assets {
		if asset.Contents != "" {
			_, err = assetCreateWithContentCmd(&asset.Command, client, []byte(asset.Contents))
		} else {
			_, err = assetCreateCmd(&asset.Command, client)
		}

		if err != nil {
			fmt.Printf("Failed to upload asset %s. Received the following error: %s\n", asset.Name, err)
		} else {
			fmt.Printf("Uploaded asset %s.\n", asset.Name)
		}
	}

	return templateLabel, nil
}

func createIsoImageAsset(c *Command, repoTemplate RepoTemplate, assets *[]Asset, templateName string, templateLabel string, createAssetCommand Command) error {
	// Only OOB templates handle ISO image upload
	if !repoTemplate.OsTemplateContents.ProvisionViaOob {
		return nil
	}

	imageRepositoryHostname := defaultImageRepositoryHostname

	if userGivenImageRepositoryHostname := os.Getenv("METALCLOUD_IMAGE_REPOSITORY_HOSTNAME"); userGivenImageRepositoryHostname != "" {
		imageRepositoryHostname = os.Getenv("METALCLOUD_IMAGE_REPOSITORY_HOSTNAME")
	}

	imagePath, _ := getStringParamOk(c.Arguments["source-iso"])

	s := strings.Split(imagePath, "/")
	ss := s[len(s)-1]
	ss = strings.ReplaceAll(ss, " ", "_")
	imageFilename := ss

	isoPath := "/" + templateName + "-" + imageFilename

	_, err := handleIsoImageUpload(c, imageRepositoryHostname, isoPath, imagePath)

	if err != nil {
		return err
	}

	assetURL := "https://" + imageRepositoryHostname + isoPath

	createIsoCommand := createAssetCommand
	createIsoCommand.FlagSet = flag.NewFlagSet("create ISO asset", flag.ExitOnError)
	createIsoCommand.Arguments = map[string]interface{}{
		"filename":               createIsoCommand.FlagSet.String("filename", imageFilename, "Asset's filename"),
		"usage":                  createIsoCommand.FlagSet.String("usage", "build_source_image", "Asset's usage."),
		"mime":                   createIsoCommand.FlagSet.String("mime", assetMimeTypeBinary, "Asset's mime type. Possible values: \""+assetMimeTypeDynamic+"\", \""+assetMimeTypeBinary+"\""),
		"url":                    createIsoCommand.FlagSet.String("url", assetURL, "Asset's source url. If present it will not read content anymore"),
		"read_content_from_pipe": createIsoCommand.FlagSet.Bool("pipe", false, "Read assets's content read from pipe instead of terminal input"),
		"template_id_or_name":    createIsoCommand.FlagSet.String("template-id", templateLabel, "Template's id or name to associate."),
		"path":                   createIsoCommand.FlagSet.String("path", "/source-image", "Path to associate asset to."),
		"variables_json":         createIsoCommand.FlagSet.String("variables-json", _nilDefaultStr, "JSON encoded variables object"),
		"delete_if_exists":       createIsoCommand.FlagSet.Bool("delete-if-exists", true, "Automatically delete the existing asset associated with the current template."),
	}

	*assets = append(*assets, Asset{
		Name:    imageFilename,
		Command: createIsoCommand,
	})

	return nil
}

func handleIsoImageUpload(c *Command, imageRepositoryHostname string, isoPath string, imagePath string) (string, error) {
	remoteDirectoryPath := defaultImageRepositorySSHPath

	if userGivenRemoteDirectoryPath := os.Getenv("METALCLOUD_IMAGE_REPOSITORY_SSH_PATH"); userGivenRemoteDirectoryPath != "" {
		remoteDirectoryPath = os.Getenv("METALCLOUD_IMAGE_REPOSITORY_SSH_PATH")
	}

	remotePath := remoteDirectoryPath + isoPath

	remoteSSHPort := defaultImageRepositorySSHPort

	if userGivenSSHPort := os.Getenv("METALCLOUD_IMAGE_REPOSITORY_SSH_PORT"); userGivenSSHPort != "" {
		remoteSSHPort = os.Getenv("METALCLOUD_IMAGE_REPOSITORY_SSH_PORT")
	}

	imageRepositoryIsoPath := defaultImageRepositoryIsoPath

	if userGivenIsoPath := os.Getenv("METALCLOUD_IMAGE_REPOSITORY_ISO_PATH"); userGivenIsoPath != "" {
		imageRepositoryIsoPath = os.Getenv("METALCLOUD_IMAGE_REPOSITORY_ISO_PATH")
	}

	// ISO upload is disabled for the moment
	s := strings.Split(isoPath, "/")
	ss := s[len(s)-1]
	ss = strings.ReplaceAll(ss, " ", "_")
	imageFilename := ss

	originalImagePath, _ := getStringParamOk(c.Arguments["source-iso"])

	remoteURL := "https://" + imageRepositoryHostname + imageRepositoryIsoPath

	fmt.Printf("Please upload ISO image %s to this path: %s\n", originalImagePath, remoteURL+"/"+imageFilename)
	return "", nil

	if !getBoolParam(c.Arguments["skip-upload-to-repo"]) {
		sshRepositoryHostname := imageRepositoryHostname + ":" + remoteSSHPort

		imageExists, err := checkRemoteFileExists(remoteURL, imageFilename)

		if err != nil {
			return "", err
		}

		if imageExists && !getBoolParam(c.Arguments["replace-if-exists"]) {
			fmt.Printf("Image %s already exists at path %s. Skipping upload. Use the 'replace-if-exists' parameter to replace the existing image.\n", imageFilename, remotePath)
			return "", nil
		}

		if imageExists {
			fmt.Printf("Replacing image %s at path %s.\n", imageFilename, remotePath)
		} else {
			fmt.Printf("Uploading new image %s at path %s.\n", imageFilename, remotePath)
		}

		if userPrivateSSHKeyPath := os.Getenv("METALCLOUD_USER_PRIVATE_OPENSSH_KEY_PATH"); userPrivateSSHKeyPath == "" {
			return "", fmt.Errorf("METALCLOUD_USER_PRIVATE_OPENSSH_KEY_PATH must be set when creating an OS template. The key is needed when uploading to the ISO repository.")
		}

		userPrivateSSHKeyPath := os.Getenv("METALCLOUD_USER_PRIVATE_OPENSSH_KEY_PATH")

		homeDir, err := os.UserHomeDir()
		if err != nil {
			return "", err
		}

		var knownHostsFilePath string

		if userGivenHostsFilePath := os.Getenv("METALCLOUD_KNOWN_HOSTS_FILE_PATH"); userGivenHostsFilePath != "" {
			knownHostsFilePath = os.Getenv("METALCLOUD_KNOWN_HOSTS_FILE_PATH")
		} else {
			knownHostsFilePath = filepath.Join(homeDir, ".ssh", "known_hosts")

			// Create the known hosts file if it does not exist.
			if _, err := os.Stat(knownHostsFilePath); errors.Is(err, os.ErrNotExist) {
				hostsFile, err := os.Create(knownHostsFilePath)

				if err != nil {
					return "", err
				}

				hostsFile.Close()
			}
		}

		hostKeyCallback, err := kh.New(knownHostsFilePath)

		if err != nil {
			return "", fmt.Errorf("Received following error when parsing the known_hosts file: %s.", err)
		}

		// Use SSH key authentication from the auth package.
		clientConfig, err := auth.PrivateKey(
			"root",
			userPrivateSSHKeyPath,
			ssh.HostKeyCallback(func(hostname string, remoteAddress net.Addr, publicKey ssh.PublicKey) error {
				var keyError *kh.KeyError
				hostsError := hostKeyCallback(hostname, remoteAddress, publicKey)

				// Reference: https://www.godoc.org/golang.org/x/crypto/ssh/knownhosts#KeyError
				//if keyErr.Want is not empty and
				if errors.As(hostsError, &keyError) {
					if len(keyError.Want) > 0 {
						// If host is known then there is key mismatch and the connection is rejected.
						fmt.Printf(`
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The key sent by the remote host is
%s.
Please contact your system administrator.
Add correct host key in %s to get rid of this message.
Host key for %s has changed and you have requested strict checking.
Host key verification failed.
`,
							serializeSSHKey(publicKey), knownHostsFilePath, hostname,
						)
						return keyError
					} else {
						// If keyErr.Want slice is empty then host is unknown.
						fmt.Printf(`
The authenticity of host '%s' can't be established.
SSH key is %s.
This key is not known by any other names.
It will be added to known_hosts file %s.
Are you sure you want to continue connecting (yes/no)?
`,
							hostname, serializeSSHKey(publicKey), knownHostsFilePath,
						)

						if getBoolParam(c.Arguments["strict-host-key-checking"]) {
							reader := bufio.NewReader(os.Stdin)
							input, err := reader.ReadString('\n')

							if err != nil {
								return err
							}

							// Remove \r and \n from input
							input = string(bytes.TrimSuffix([]byte(input), []byte("\r\n")))

							if input != "yes" {
								if input == "no" {
									fmt.Println("Aborting connection.")
								} else {
									fmt.Println("Invalid response given. Aborting connection.")
								}

								return keyError
							}
						} else {
							fmt.Printf("Skipped manual check because 'strict-host-key-checking' is set to false.")
						}

						return addHostKey(knownHostsFilePath, remoteAddress, publicKey)
					}
				}

				fmt.Printf("Public key exists for remote %s. Establishing connection.\n", hostname)
				return nil
			}),
		)

		if err != nil {
			return "", fmt.Errorf("Could not create SSH client config. Received error: %s", err)
		}

		// Create a new SCP client.
		scpClient := scp.NewClient(sshRepositoryHostname, &clientConfig)

		// Connect to the remote server.
		err = scpClient.Connect()
		if err != nil {
			return "", fmt.Errorf("Couldn't establish a connection to the remote server: %s", err)
		}

		defer scpClient.Close()

		fmt.Printf("Established connection to hostname %s.\n", sshRepositoryHostname)

		isoImagefile, err := os.Open(imagePath)
		if err != nil {
			return "", fmt.Errorf("Image not found at path %s.", imagePath)
		}
		defer isoImagefile.Close()

		fmt.Printf("Starting image upload to repository at path %s.\n", remotePath)
		err = scpClient.CopyFile(context.Background(), isoImagefile, remotePath, "0777")

		if err != nil {
			return "", fmt.Errorf("Error while copying file: %s", err)
		}

		fmt.Printf("Finished image upload to repository at path %s.\n", remotePath)

	} else {
		fmt.Printf("Skipped uploading image to repository at path %s.", remotePath)
	}

	return "", nil
}

func createOtherAssets(c *Command, repoTemplate RepoTemplate, assets *[]Asset, templateName string, templateLabel string, createAssetCommand Command) error {
	if value, ok := getStringParamOk(c.Arguments["assets-update"]); ok {
		assetsUpdateString := value

		// Format is: template_asset_1:/local_replace_asset_1,template_asset_2:/local_replace_asset_2
		assetParts := strings.Split(assetsUpdateString, ",")
		for _, assetPart := range assetParts {
			parts := strings.Split(assetPart, ":")

			if len(parts) != 2 {
				return fmt.Errorf("Invalid format detected for 'assets-update' parameter. Asset update parts must be separated by commas and each asset update part must have the name of the asset file which contents will be replaced, followed by ':' and the local path to the new asset. Check build command for an example.")
			}

			templateAssetName := parts[0]
			localAssetPath := parts[1]

			if _, ok := repoTemplate.Assets[templateAssetName]; !ok {
				return fmt.Errorf("Asset with name %s not found in the template.yaml file. Only assets found there can have their contents replaced.", templateAssetName)
			}

			localAssetFile, err := os.Open(localAssetPath)

			if err != nil {
				return fmt.Errorf("Asset file not found at path %s.", localAssetPath)
			}
			defer localAssetFile.Close()

			fileBytes, err := os.ReadFile(localAssetPath)
			asset := repoTemplate.Assets[templateAssetName]
			asset.contents = string(fileBytes)
			repoTemplate.Assets[templateAssetName] = asset
		}
	}

	imageRepositoryHostname := defaultImageRepositoryHostname

	if userGivenImageRepositoryHostname := os.Getenv("METALCLOUD_IMAGE_REPOSITORY_HOSTNAME"); userGivenImageRepositoryHostname != "" {
		imageRepositoryHostname = os.Getenv("METALCLOUD_IMAGE_REPOSITORY_HOSTNAME")
	}

	for _, asset := range repoTemplate.Assets {
		assetContents := asset.contents

		if asset.Usage == "" {
			asset.Usage = _nilDefaultStr
		}

		var assetURL string

		if asset.Url == "" {
			assetURL = _nilDefaultStr
		} else {
			assetURL = "https://" + imageRepositoryHostname + asset.Url
		}

		// For OOB templates, isopath is populated, for non-OOB ones, path is used instead.
		var assetPath string

		if repoTemplate.OsTemplateContents.ProvisionViaOob {
			assetPath = asset.Isopath
		} else {
			assetPath = asset.Path
		}

		createOtherAssetCommand := createAssetCommand
		createOtherAssetCommand.FlagSet = flag.NewFlagSet("create asset "+asset.name, flag.ExitOnError)
		createOtherAssetCommand.Arguments = map[string]interface{}{
			"filename":               createOtherAssetCommand.FlagSet.String("filename", asset.name, "Asset's filename"),
			"usage":                  createOtherAssetCommand.FlagSet.String("usage", asset.Usage, "Asset's usage."),
			"mime":                   createOtherAssetCommand.FlagSet.String("mime", asset.Mime, "Asset's mime type. Possible values: \""+assetMimeTypeDynamic+"\",\""+assetMimeTypeBinary+"\""),
			"url":                    createOtherAssetCommand.FlagSet.String("url", assetURL, "Asset's source url. If present it will not read content anymore"),
			"read_content_from_pipe": createOtherAssetCommand.FlagSet.Bool("pipe", false, "Read assets's content read from pipe instead of terminal input"),
			"template_id_or_name":    createOtherAssetCommand.FlagSet.String("template-id", templateLabel, "Template's id or name to associate. "),
			"path":                   createOtherAssetCommand.FlagSet.String("path", assetPath, "Path to associate asset to."),
			"variables_json":         createOtherAssetCommand.FlagSet.String("variables-json", _nilDefaultStr, "JSON encoded variables object"),
			"delete_if_exists":       createOtherAssetCommand.FlagSet.Bool("delete-if-exists", true, "Automatically delete the existing asset associated with the current template."),
		}

		*assets = append(*assets, Asset{
			Name:     asset.name,
			Command:  createOtherAssetCommand,
			Contents: assetContents,
		})
	}

	return nil
}

func templateDiffCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {
	var filePath1, filePath2, outputFilePath string

	if file1, ok := getStringParamOk(c.Arguments["file1"]); ok {
		filePath1 = file1
	} else {
		return "", fmt.Errorf("Did not find the 'file1' parameter.")
	}

	if file2, ok := getStringParamOk(c.Arguments["file2"]); ok {
		filePath2 = file2
	} else {
		return "", fmt.Errorf("Did not find the 'file2' parameter.")
	}

	if outputFile, ok := getStringParamOk(c.Arguments["output-file"]); ok {
		outputFilePath = outputFile
	} else {
		return "", fmt.Errorf("Did not find the 'output-file' parameter.")
	}

	fileContents1, err := os.ReadFile(filePath1)

	if err != nil {
		return "", err
	}

	fileContents2, err := os.ReadFile(filePath2)

	if err != nil {
		return "", err
	}

	diffMatchPatch := diff.New()

	diffs := diffMatchPatch.DiffMain(string(fileContents1), string(fileContents2), false)
	patches := diffMatchPatch.PatchMake(diffs)
	patchText := diffMatchPatch.PatchToText(patches)

	file, err := os.Create(outputFilePath)

	if err != nil {
		return "", nil
	}
	defer file.Close()

	writer := bufio.NewWriter(file)

	_, err = fmt.Fprintf(writer, "%s", patchText)
	if err != nil {
		return "", nil
	}

	writer.Flush()
	return "", nil
}

func templateListRepoCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {
	repoMap := make(map[string]RepoTemplate)
	err := retrieveRepositoryAssets(c, repoMap)

	if err != nil {
		return "", err
	}

	table := createRepositoryTemplatesTable(repoMap)
	return table.RenderTable("Repository templates", "", getStringParam(c.Arguments["format"]))
}

func templateListAssetsCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {
	var sourceTemplate string

	if sourceTemplateValue, ok := getStringParamOk(c.Arguments["source-template"]); !ok {
		return "", fmt.Errorf("The 'source-template' parameter must be specified when using the 'list-source-template-assets' command.")
	} else {
		sourceTemplate = sourceTemplateValue
	}

	useLocalTemplate := false

	if repoValue, ok := getStringParamOk(c.Arguments["repo"]); ok {
		if repoValue == localRepositoryName {
			useLocalTemplate = true
		}
	}

	var table tableformatter.Table

	if !useLocalTemplate {
		repoMap := make(map[string]RepoTemplate)
		err := retrieveRepositoryAssets(c, repoMap)

		if err != nil {
			return "", err
		}

		if _, ok := repoMap[sourceTemplate]; !ok {
			return "", fmt.Errorf("Did not find source template '%s' in the repository.", sourceTemplate)
		}

		table = createTemplateAssetsTable(repoMap[sourceTemplate])
	} else {
		_, err := os.ReadFile(sourceTemplate)

		if err != nil {
			return "", fmt.Errorf("Template file not found at path %s.", sourceTemplate)
		}

		repoTemplate := RepoTemplate{}

		getLocalTemplateAssets(filepath.Dir(sourceTemplate), &repoTemplate)
		templateHasErrors, err := populateTemplateValues(&repoTemplate)

		if err != nil {
			return "", err
		}

		if templateHasErrors {
			fmt.Printf("Found errors for template file %s! Use the 'validate-template' function to see them and fix them.\n", sourceTemplate)
		}

		table = createTemplateAssetsTable(repoTemplate)
	}

	return table.RenderTable("Template assets", "", getStringParam(c.Arguments["format"]))
}

func templateValidateRepoCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {
	repoMap := make(map[string]RepoTemplate)
	err := retrieveRepositoryAssets(c, repoMap)

	if err != nil {
		return "", err
	}

	for templatePreffix, repoTemplate := range repoMap {
		if len(repoTemplate.Errors) != 0 {
			fmt.Printf("Detected the following errors regarding repository structure for template %s:\n", templatePreffix)
		}

		for _, errorMessage := range repoTemplate.Errors {
			fmt.Println("\t" + errorMessage)
		}
	}

	return "", err
}

func templateValidateCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {
	var sourceTemplate string

	if sourceTemplateValue, ok := getStringParamOk(c.Arguments["source-template"]); !ok {
		return "", fmt.Errorf("The 'source-template' parameter must be specified when using the 'validate-template' command.")
	} else {
		sourceTemplate = sourceTemplateValue
	}

	useLocalTemplate := false

	if repoValue, ok := getStringParamOk(c.Arguments["repo"]); ok {
		if repoValue == localRepositoryName {
			useLocalTemplate = true
		}
	}

	var repoTemplate RepoTemplate

	if !useLocalTemplate {
		repoMap := make(map[string]RepoTemplate)
		err := retrieveRepositoryAssets(c, repoMap)

		if err != nil {
			return "", err
		}

		if _, ok := repoMap[sourceTemplate]; !ok {
			return "", fmt.Errorf("Did not find source template '%s' in the repository.", sourceTemplate)
		}

		repoTemplate = repoMap[sourceTemplate]
	} else {
		fmt.Printf("Did not find source template '%s' in the repository, checking for local file.\n", sourceTemplate)

		_, err := os.ReadFile(sourceTemplate)

		if err != nil {
			return "", fmt.Errorf("Template file not found at path %s.", sourceTemplate)
		}

		getLocalTemplateAssets(filepath.Dir(sourceTemplate), &repoTemplate)
		_, err = populateTemplateValues(&repoTemplate)

		if err != nil {
			return "", err
		}
	}

	if len(repoTemplate.Errors) != 0 {
		fmt.Printf("Detected the following errors regarding template structure for template %s:\n", sourceTemplate)
	} else {
		fmt.Printf("Detected no errors for the given template.\n")
	}

	for _, errorMessage := range repoTemplate.Errors {
		fmt.Println("\t" + errorMessage)
	}

	return "", nil
}

func getOSTemplateFromCommand(paramName string, c *Command, client metalcloud.MetalCloudClient, decryptPasswd bool) (*metalcloud.OSTemplate, error) {
	v, err := getParam(c, "template_id_or_name", paramName)
	if err != nil {
		return nil, err
	}

	id, label, isID := idOrLabel(v)

	if isID {
		return client.OSTemplateGet(id, decryptPasswd)
	}

	list, err := client.OSTemplates()
	if err != nil {
		return nil, err
	}

	for _, s := range *list {
		if s.VolumeTemplateLabel == label {
			return &s, nil
		}
	}

	if isID {
		return nil, fmt.Errorf("template %d not found", id)
	}

	return nil, fmt.Errorf("template %s not found", label)
}

func getUserFromCommand(paramName string, c *Command, client metalcloud.MetalCloudClient) (*metalcloud.User, error) {
	user, err := getParam(c, "user_id", paramName)
	if err != nil {
		return nil, err
	}

	id, email, isID := idOrLabel(user)

	if isID {
		return client.UserGet(id)
	} else {
		return client.UserGetByEmail(email)
	}
}

func stringInSlice(a string, list []string) bool {
	for _, b := range list {
		if b == a {
			return true
		}
	}
	return false
}

func sliceDifference(slice1 []string, slice2 []string) []string {
	var diff []string

	for _, s1 := range slice1 {
		found := false

		for _, s2 := range slice2 {
			if s1 == s2 {
				found = true
				break
			}
		}

		if !found {
			diff = append(diff, s1)
		}
	}

	return diff
}

// Add host key if host is not found in known_hosts.
// The return object is the error, if nil then connection proceeds, else connection stops.
func addHostKey(knownHostsFilePath string, remoteAddress net.Addr, publicKey ssh.PublicKey) error {
	knownHostsFile, err := os.OpenFile(knownHostsFilePath, os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		return fmt.Errorf("Hosts file not found at path %s.", knownHostsFilePath)
	}
	defer knownHostsFile.Close()

	fileBytes, err := os.ReadFile(knownHostsFilePath)

	// We add an empty line if the file doesn't end in one and if it's not empty to begin with.
	if len(fileBytes) > 0 && string(fileBytes[len(fileBytes)-1]) != "\r" && string(fileBytes[len(fileBytes)-1]) != "\n" {
		_, err = knownHostsFile.WriteString("\n")

		if err != nil {
			return err
		}
	}

	knownHosts := kh.Normalize(remoteAddress.String())
	_, err = knownHostsFile.WriteString(kh.Line([]string{knownHosts}, publicKey))

	fmt.Printf("Added key %s to known_hosts file %s.", serializeSSHKey(publicKey), knownHostsFilePath)
	return err
}

func serializeSSHKey(key ssh.PublicKey) string {
	return key.Type() + " " + base64.StdEncoding.EncodeToString(key.Marshal())
}

func checkRemoteFileExists(remoteURL string, fileName string) (bool, error) {
	resp, err := netHTTP.Get(remoteURL)

	if err != nil {
		return false, err
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return false, err
	}

	responseBody := string(body)
	return strings.Contains(responseBody, fileName), nil
}

func getRepositoryTemplateAssets(tree *object.Tree, repoMap map[string]RepoTemplate, repoAssetsPerTemplate map[string][]TemplateAsset) {
	files := tree.Files()
	files.ForEach(func(file *object.File) error {
		if file.Mode.IsRegular() {
			if strings.Count(file.Name, "/") == 3 {
				parts := strings.Split(file.Name, "/")
				templatePreffix := strings.Join(parts[:3], "/")

				fileContents, err := file.Contents()

				if err != nil {
					return err
				}

				if parts[3] == templateFileName {
					if _, ok := repoMap[templatePreffix]; !ok {
						repoMap[templatePreffix] = RepoTemplate{
							SourcePath:           templatePreffix,
							TemplateFileContents: fileContents,
						}
					}
				} else if parts[3] != readMeFileName {
					asset := TemplateAsset{
						name:     parts[3],
						contents: fileContents,
					}

					repoAssetsPerTemplate[templatePreffix] = append(repoAssetsPerTemplate[templatePreffix], asset)
				}
			}
		}

		return nil
	})
}

func getLocalTemplateAssets(dirName string, repoTemplate *RepoTemplate) error {
	f, err := os.Open(dirName)

	if err != nil {
		return err
	}

	files, err := f.Readdir(-1)
	f.Close()
	if err != nil {
		return err
	}

	repoAssets := []TemplateAsset{}

	for _, file := range files {
		if file.IsDir() || file.Name() == readMeFileName {
			continue
		}

		fileBytes, err := os.ReadFile(file.Name())

		if err != nil {
			return err
		}

		fileContents := string(fileBytes)

		if file.Name() == templateFileName {
			repoTemplate.SourcePath = templateFileName
			repoTemplate.TemplateFileContents = fileContents
		} else {
			asset := TemplateAsset{
				name:     file.Name(),
				contents: fileContents,
			}

			repoAssets = append(repoAssets, asset)
		}
	}

	repoTemplate.Assets = make(map[string]TemplateAsset)
	for _, asset := range repoAssets {
		repoTemplate.Assets[asset.name] = asset
	}

	return nil
}

func populateTemplateValues(repoTemplate *RepoTemplate) (bool, error) {
	templateHasErrors := false
	templateStringContents := repoTemplate.TemplateFileContents

	var templateContents TemplateContents
	err := yaml.Unmarshal([]byte(templateStringContents), &templateContents)

	if err != nil {
		return templateHasErrors, err
	}

	repoTemplate.OsTemplateContents = templateContents.OsTemplateContents

	architecture := templateContents.OsTemplateContents.OsArchitecture
	deployProcess := templateContents.OsTemplateContents.BootMethodsSupported
	bootType := templateContents.OsTemplateContents.BootType
	osType := templateContents.OsTemplateContents.OsType
	version := templateContents.OsTemplateContents.OsVersion

	validArchitectures := []string{osArchitecture64}
	validDeployProcesses := []string{bootMethodLocalDrives, bootMethodPxeIscsi}
	validBootTypes := []string{bootTypeUEFIOnly, bootTypeLegacyOnly}
	validMimeTypes := []string{assetMimeTypeBinary, assetMimeTypeDynamic}
	validAssetTypes := []string{assetTypeBootloader, assetTypeBootloaderConfig, assetTypeInstallerConfig, assetTypePatch, assetTypeOther}
	validUsageType := []string{assetUsageTypeBootloader, assetUsageTypeBuildComponent}

	errors := []string{}

	if osType == "" {
		errors = append(errors, fmt.Sprintf("Found no OS type. There must be one in the os-template section with the key name 'os-type'."))
	}

	if version == "" {
		errors = append(errors, fmt.Sprintf("Found no OS version. There must be one in the os-template section with the key name 'os-version'."))
	}

	if architecture == "" {
		errors = append(errors, fmt.Sprintf("Found no OS architecture. There must be one in the os-template section with the key name 'os-architecture'. Valid architectures are %+q.", validArchitectures))
	} else if !stringInSlice(architecture, validArchitectures) {
		errors = append(errors, fmt.Sprintf("Found invalid architecture %s. Valid architectures are %+q.", architecture, validArchitectures))
	}

	if deployProcess == "" {
		errors = append(errors, fmt.Sprintf("Found no deploy process. There must be one in the os-template section with the key name 'boot-methods-supported'. Valid boot methods are %+q.", validDeployProcesses))
	} else if !stringInSlice(deployProcess, validDeployProcesses) {
		errors = append(errors, fmt.Sprintf("Found invalid boot method %s. Valid boot methods are %+q.", deployProcess, validDeployProcesses))
	}

	if bootType == "" {
		errors = append(errors, fmt.Sprintf("Found no boot type. There must be one in the os-template section with the key name 'boot-type'. Valid boot types are %+q.", validBootTypes))
	} else if !stringInSlice(bootType, validBootTypes) {
		errors = append(errors, fmt.Sprintf("Found invalid boot type %s. Valid boot types are %+q.", bootType, validBootTypes))
	}

	var repoFileNames, templateFileNames []string

	for assetName, asset := range repoTemplate.Assets {
		assetContents := asset.contents

		// We ignore the ReadMe file
		if assetName == readMeFileName {
			continue
		}
		repoFileNames = append(repoFileNames, assetName)

		if asset, ok := templateContents.Assets[assetName]; ok {
			if asset.Mime == "" {
				errors = append(errors, fmt.Sprintf("Found no mime type for asset %s. There must be one for the asset with the key name 'mime'. Valid mime types are %+q.", assetName, validMimeTypes))
			} else if !stringInSlice(asset.Mime, validMimeTypes) {
				errors = append(errors, fmt.Sprintf("Found invalid mime type %s for asset %s. Valid mime types are %+q.", asset.Mime, assetName, validMimeTypes))
			}

			if asset.Type == "" {
				errors = append(errors, fmt.Sprintf("Found no asset type for asset %s. There must be one for the asset with the key name 'type'. Valid asset types are %+q.", assetName, validAssetTypes))
			} else if !stringInSlice(asset.Type, validAssetTypes) {
				errors = append(errors, fmt.Sprintf("Found invalid asset type %v for asset %s. Valid asset types are %+q.", asset.Type, assetName, validAssetTypes))
			}

			if asset.Usage != "" && !stringInSlice(asset.Usage, validUsageType) {
				errors = append(errors, fmt.Sprintf("Found invalid usage type %v for asset %s. Property is not required and the valid usage types are %+q.", asset.Usage, assetName, validUsageType))
			}

			// For OOB templates, isopath is populated, for non-OOB ones, path is used instead.
			if repoTemplate.OsTemplateContents.ProvisionViaOob {
				if asset.Isopath == "" {
					errors = append(errors, fmt.Sprintf("Found no isopath for asset %s. There must be one for the asset with the key name 'isopath', as the asset is part of an OOB template.", assetName))
				}
			} else if asset.Path == "" {
				errors = append(errors, fmt.Sprintf("Found no path for asset %s. There must be one for the asset with the key name 'path', as the asset is part of a non-OOB template.", assetName))
			}

			asset.name = assetName
			asset.contents = assetContents
			repoTemplate.Assets[assetName] = asset
		}
	}

	// Add the assets that are part of non-OOB templates and are not physically in the repository.
	if !repoTemplate.OsTemplateContents.ProvisionViaOob {
		for assetName, asset := range templateContents.Assets {
			if asset.Url != "" {
				if asset.Path == "" {
					errors = append(errors, fmt.Sprintf("Found no path for asset %s. There must be one for the asset with the key name 'path', as the asset is part of a non-OOB template.", assetName))
				}

				asset.name = assetName
				repoTemplate.Assets[assetName] = asset
			}
		}
	}

	for assetName, asset := range templateContents.Assets {
		// We ignore files that have an URL, since they don't need to be in the repository.
		if asset.Url != "" {
			continue
		}
		templateFileNames = append(templateFileNames, assetName)
	}

	fileNamesNotInTemplate := sliceDifference(repoFileNames, templateFileNames)
	fileNamesNotInRepository := sliceDifference(templateFileNames, repoFileNames)

	if len(fileNamesNotInTemplate) != 0 {
		errors = append(errors, fmt.Sprintf("Found the following repository files that are not in the %s file: %+q.", templateFileName, fileNamesNotInTemplate))
	}

	if len(fileNamesNotInRepository) != 0 {
		errors = append(errors, fmt.Sprintf("Found the following files declared in %s that are not in the repository: %+q.", templateFileName, fileNamesNotInRepository))
	}

	repoTemplate.Errors = errors

	if len(errors) != 0 {
		templateHasErrors = true
	}

	repoTemplate.Architecture = architecture
	repoTemplate.DeployProcess = deployProcess
	repoTemplate.BootType = bootType
	repoTemplate.Type = osType
	repoTemplate.Version = version

	return templateHasErrors, err
}
