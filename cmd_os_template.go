package main

import (
	"bufio"
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"net"
	"os"
	"path/filepath"
	"strings"

	metalcloud "github.com/metalsoft-io/metal-cloud-sdk-go/v2"
	"github.com/metalsoft-io/tableformatter"
	"gopkg.in/yaml.v3"

	"github.com/go-git/go-billy/v5/memfs"
	git "github.com/go-git/go-git/v5"

	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/go-git/go-git/v5/plumbing/transport/http"
	diff "github.com/sergi/go-diff/diffmatchpatch"

	memory "github.com/go-git/go-git/v5/storage/memory"

	"github.com/kdomanski/iso9660"

	"github.com/bramvdbogaerde/go-scp"
	"github.com/bramvdbogaerde/go-scp/auth"
	"golang.org/x/crypto/ssh"

	kh "golang.org/x/crypto/ssh/knownhosts"

	netHTTP "net/http"
)

// Constants used with the build command
const osArchitecture64 = "x86_64"

const bootMethodLocalDrives = "local_drives"
const bootMethodPxeIscsi = "pxe_iscsi"

const bootTypeUEFIOnly = "uefi_only"
const bootTypeLegacyOnly = "legacy_only"

const bootloaderConfigFileName = "BOOT.CFG"

const assetTypeBootloader = "bootloader"
const assetTypeBootloaderConfig = "bootloader-config"
const assetTypeInstallerConfig = "installer-config"
const assetTypePatch = "patch"
const assetTypeOther = "other"

const assetMimeTypeDynamic = "text/plain"
const assetMimeTypeBinary = "application/octet-stream"

const assetJSONTypeDynamic = "dynamic"
const assetJSONTypeBinary = "binary"

const remoteDirectoryPath = "/var/www/html/"
const otherAssetsMaximumSizeBytes = 2097152

type TemplateAsset struct {
	file    object.File
	Isopath string `yaml:"isopath"`
	Mime    string `yaml:"mime"`
	Usage   string `yaml:"usage"`
	Type    string `yaml:"type"`
	Url     string `yaml:"url"`
	Path    string `yaml:"path"`
}

type OsTemplateContents struct {
	BootType                        string `yaml:"boot-type"`
	BootMethodsSupported            string `yaml:"boot-methods-supported"`
	OsVersion                       string `yaml:"os-version"`
	OsArchitecture                  string `yaml:"os-architecture"`
	OsReadyMethod                   string `yaml:"os-ready-method"`
	ImageBuildRequired              bool   `yaml:"image-build-required"`
	ProvisionViaOob                 bool   `yaml:"provision-via-oob"`
	InitialUser                     string `yaml:"initial-user"`
	InitialSSHPort                  int    `yaml:"initial-ssh-port"`
	UseAutogeneratedInitialPassword bool   `yaml:"use-autogenerated-initial-password"`
	InstallBootloaderAsset          string `yaml:"install-bootloader-asset"`
	OsBootBootloaderAsset           string `yaml:"os-boot-bootloader-asset"`
}

type TemplateContents struct {
	OsTemplateContents OsTemplateContents       `yaml:"os-template"`
	Assets             map[string]TemplateAsset `yaml:"assets"`
}

// Struct containing the values that will be printed out for a repo template
type RepoTemplate struct {
	Family             string
	Version            string
	Architecture       string
	DeployProcess      string
	BootType           string
	SourcePath         string
	TemplateFile       object.File
	OsTemplateContents OsTemplateContents
	Assets             []TemplateAsset
	Warnings           []string
}

// Struct containing assets that are to be created after all checks are done.
type Asset struct {
	Name     string
	Command  Command
	Contents string
}

type InputAsset struct {
	LocalPath string `json:"path"`
	IsoPath   string `json:"isopath"`
	Type      string `json:"type"`
}

var osTemplatesCmds = []Command{

	{
		Description:  "Lists available templates.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "list",
		AltPredicate: "ls",
		FlagSet:      flag.NewFlagSet("list templates", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"format": c.FlagSet.String("format", _nilDefaultStr, "The output format. Supported values are 'json','csv','yaml'. The default format is human readable."),
				"usage":  c.FlagSet.String("usage", _nilDefaultStr, "Template's usage"),
			}
		},
		ExecuteFunc: templatesListCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "Create a template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "create",
		AltPredicate: "new",
		FlagSet:      flag.NewFlagSet("create template", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"label":                              c.FlagSet.String("label", _nilDefaultStr, red("(Required)")+" Template's label"),
				"display_name":                       c.FlagSet.String("display-name", _nilDefaultStr, red("(Required)")+" Template's display name"),
				"size":                               c.FlagSet.Int("size", _nilDefaultInt, "Template's size (bytes)"),
				"boot_methods_supported":             c.FlagSet.String("boot-methods-supported", _nilDefaultStr, red("(Required)")+" Template boot methods supported. Defaults to pxe_iscsi."),
				"os_bootstrap_function_name":         c.FlagSet.String("os-bootstrap-function-name", _nilDefaultStr, "Optional property that selects the cloudinit configuration function. Can be one of: provisioner_os_cloudinit_prepare_centos, provisioner_os_cloudinit_prepare_rhel, provisioner_os_cloudinit_prepare_ubuntu, provisioner_os_cloudinit_prepare_windows."),
				"boot_type":                          c.FlagSet.String("boot-type", _nilDefaultStr, red("(Required)")+" Template boot type. Possible values: 'uefi_only','legacy_only' "),
				"description":                        c.FlagSet.String("description", _nilDefaultStr, "Template description"),
				"os_type":                            c.FlagSet.String("os-type", _nilDefaultStr, red("(Required)")+" Template operating system type. For example, Ubuntu or CentOS."),
				"os_version":                         c.FlagSet.String("os-version", _nilDefaultStr, red("(Required)")+" Template operating system version."),
				"os_architecture":                    c.FlagSet.String("os-architecture", _nilDefaultStr, red("(Required)")+" Template operating system architecture.Possible values: none, unknown, x86, x86_64."),
				"initial_user":                       c.FlagSet.String("initial-user", _nilDefaultStr, red("(Required)")+" Template's initial username, used to verify install."),
				"initial_password":                   c.FlagSet.String("initial-password", _nilDefaultStr, red("(Required)")+" Template's initial password, used to verify install."),
				"use_autogenerated_initial_password": c.FlagSet.Bool("use-autogenerated-initial-password", false, green("(Flag)")+" If set will automatically generate a password for the template and provide it during install via the initial_password and initial_user variables. Cannot be used withinitial-password and initial-user params."),
				"initial_ssh_port":                   c.FlagSet.Int("initial-ssh-port", _nilDefaultInt, red("(Required)")+" Template's initial ssh port, used to verify install."),
				"change_password_after_deploy":       c.FlagSet.Bool("change-password-after-deploy", false, "Option to change the initial_user password on the installed OS after deploy."),
				"image_build_required":               c.FlagSet.Bool("image-build-required", false, green("(Flag)")+" If set will determine the image building process building an ISO. Needed for the OOB only install process."),
				"provision_via_oob":                  c.FlagSet.Bool("provision-via-oob", false, green("(Flag)")+" If set will perform the installation process via the OOB. Always set this together with the image-build-required flag."),
				"repo_url":                           c.FlagSet.String("repo-url", _nilDefaultStr, "Template's location the repository"),
				"os_ready_method":                    c.FlagSet.String("os-ready-method", _nilDefaultStr, "Possible values: 'wait_for_ssh', 'wait_for_signal_from_os'. Default value: 'wait_for_ssh'."),
				"os_asset_id_bootloader_local_install_id_or_name": c.FlagSet.String("install-bootloader-asset", _nilDefaultStr, "Template's bootloader asset id during install"),
				"os_asset_id_bootloader_os_boot_id_or_name":       c.FlagSet.String("os-boot-bootloader-asset", _nilDefaultStr, "Template's bootloader asset id during regular server boot"),
				"version": c.FlagSet.String("version", _nilDefaultStr, "Template version. Default value is 0.0.0"),

				"return-id": c.FlagSet.Bool("return-id", false, green("(Flag)")+" If set will print the ID of the created infrastructure. Useful for automating tasks."),
			}
		},
		ExecuteFunc: templateCreateCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "Edit a template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "update",
		AltPredicate: "edit",
		FlagSet:      flag.NewFlagSet("update template", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name":        c.FlagSet.String("id", _nilDefaultStr, red("(Required)")+" Template's id or label"),
				"label":                      c.FlagSet.String("label", _nilDefaultStr, red("(Required)")+" Template's label"),
				"display_name":               c.FlagSet.String("display-name", _nilDefaultStr, red("(Required)")+" Template's display name"),
				"size":                       c.FlagSet.Int("size", _nilDefaultInt, "Template's size (bytes)"),
				"boot_methods_supported":     c.FlagSet.String("boot-methods-supported", _nilDefaultStr, "Template boot methods supported. Defaults to pxe_iscsi."),
				"os_bootstrap_function_name": c.FlagSet.String("os-bootstrap-function-name", _nilDefaultStr, "Optional property that selects the cloudinit configuration function. Can be one of: provisioner_os_cloudinit_prepare_centos, provisioner_os_cloudinit_prepare_rhel, provisioner_os_cloudinit_prepare_ubuntu, provisioner_os_cloudinit_prepare_windows."),
				"boot_type":                  c.FlagSet.String("boot-type", _nilDefaultStr, red("(Required)")+" Template boot type. Possible values: 'uefi_only','legacy_only' "),
				"description":                c.FlagSet.String("description", _nilDefaultStr, "Template description"),
				"os_type":                    c.FlagSet.String("os-type", _nilDefaultStr, red("(Required)")+" Template operating system type. For example, Ubuntu or CentOS."),
				"os_version":                 c.FlagSet.String("os-version", _nilDefaultStr, red("(Required)")+" Template operating system version."),
				"os_architecture":            c.FlagSet.String("os-architecture", _nilDefaultStr, red("(Required)")+" Template operating system architecture.Possible values: none, unknown, x86, x86_64."),
				"os_asset_id_bootloader_local_install_id_or_name": c.FlagSet.String("install-bootloader-asset", _nilDefaultStr, "Template's bootloader asset id during install"),
				"os_asset_id_bootloader_os_boot_id_or_name":       c.FlagSet.String("os-boot-bootloader-asset", _nilDefaultStr, "Template's bootloader asset id during regular server boot"),
				"initial_user":                       c.FlagSet.String("initial-user", _nilDefaultStr, red("(Required)")+" Template's initial username, used to verify install."),
				"initial_password":                   c.FlagSet.String("initial-password", _nilDefaultStr, red("(Required)")+" Template's initial password, used to verify install."),
				"use_autogenerated_initial_password": c.FlagSet.Bool("use-autogenerated-initial-password", false, green("(Flag)")+" If set will automatically generate a password for the template and provide it during install via the initial_password and initial_user variables. Cannot be used with --initial-password, requires --initial-user params."),
				"initial_ssh_port":                   c.FlagSet.Int("initial-ssh-port", _nilDefaultInt, red("(Required)")+" Template's initial ssh port, used to verify install."),
				"os_ready_method":                    c.FlagSet.String("os-ready-method", _nilDefaultStr, "Possible values: 'wait_for_ssh', 'wait_for_signal_from_os'. Default value: 'wait_for_ssh'."),
				"change_password_after_deploy":       c.FlagSet.Bool("change-password-after-deploy", false, "Option to change the initial_user password on the installed OS after deploy."),
				"image_build_required":               c.FlagSet.Bool("image-build-required", false, green("(Flag)")+" If set will determine the image building process building an ISO. Needed for the OOB only install process."),
				"provision_via_oob":                  c.FlagSet.Bool("provision-via-oob", false, green("(Flag)")+" If set will perform the installation process via the OOB. Always set this together with the image-build-required flag."),
				"repo_url":                           c.FlagSet.String("repo-url", _nilDefaultStr, "Template description"),
			}
		},
		ExecuteFunc: templateEditCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "Get a template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "get",
		AltPredicate: "show",
		FlagSet:      flag.NewFlagSet("get template", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", _nilDefaultStr, "Asset's id or name"),
				"format":              c.FlagSet.String("format", _nilDefaultStr, "The output format. Supported values are 'json','csv','yaml'. The default format is human readable."),
				"show_credentials":    c.FlagSet.Bool("show-credentials", false, green("(Flag)")+" If set returns the templates initial ssh credentials"),
			}
		},
		ExecuteFunc: templateGetCmd,
		Endpoint:    DeveloperEndpoint,
	},
	{
		Description:  "Delete a template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "delete",
		AltPredicate: "rm",
		FlagSet:      flag.NewFlagSet("delete template", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", _nilDefaultStr, "Asset's id or name"),
				"autoconfirm":         c.FlagSet.Bool("autoconfirm", false, green("(Flag)")+" If set it will assume action is confirmed"),
			}
		},
		ExecuteFunc: templateDeleteCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "Allow other users of the platform to use the template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "make-public",
		AltPredicate: "public",
		FlagSet:      flag.NewFlagSet("make template public", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", _nilDefaultStr, "Template id or name"),
			}
		},
		ExecuteFunc: templateMakePublicCmd,
		Endpoint:    DeveloperEndpoint,
	},
	{
		Description:  "Stop other users of the platform from being able to use the template by allocating a specific owner.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "make-private",
		AltPredicate: "private",
		FlagSet:      flag.NewFlagSet("make template private", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", _nilDefaultStr, "Template id or name"),
				"user_id":             c.FlagSet.String("user-id", _nilDefaultStr, "New owner user id or email."),
			}
		},
		ExecuteFunc: templateMakePrivateCmd,
		Endpoint:    DeveloperEndpoint,
	},
	{
		Description:  "List associated assets.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "list-assets",
		AltPredicate: "assoc",
		FlagSet:      flag.NewFlagSet("associated assets", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"template_id_or_name": c.FlagSet.String("id", _nilDefaultStr, "Template's id or name"),
			}
		},
		ExecuteFunc: templateListAssociatedAssetsCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "Build an OS template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "build",
		AltPredicate: "build",
		FlagSet:      flag.NewFlagSet("build an OS template from a source ISO image", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"name":                 c.FlagSet.String("name", _nilDefaultStr, red("(Required)")+"Name of image."),
				"source-template":      c.FlagSet.String("source-template", _nilDefaultStr, red("(Required)")+"The source template to use as a base. It has the format of 'family/architecture'. Use --list-supported for a list of accepted values."),
				"source-iso":           c.FlagSet.String("source-iso", _nilDefaultStr, red("(Required)")+"The source ISO image path."),
				"kickstart":            c.FlagSet.String("kickstart", _nilDefaultStr, yellow("(Optional)")+"The OS's kickstart or equivalent file to be uploaded instead of the default."),
				"kickstart-append":     c.FlagSet.String("kickstart-append", _nilDefaultStr, yellow("(Optional)")+"Content to append to the default kickstart."),
				"bootloader":           c.FlagSet.String("bootloader", _nilDefaultStr, yellow("(Optional)")+"The OS's instalation bootloader to be uploaded instead of the default."),
				"bootloader-config":    c.FlagSet.String("bootloader-config", _nilDefaultStr, yellow("(Optional)")+"The OS's installation bootloader config file to be uploaded instead of the default."),
				"other-assets-json":    c.FlagSet.String("other-assets-json", _nilDefaultStr, yellow("(Optional)")+"Dynamic or binary files that will be replaced inside the template. Can contain variables. Limited to 2MB in size."),
				"github-template-repo": c.FlagSet.String("github-template-repo", _nilDefaultStr, yellow("(Optional)")+"Override the default github url used to download template files for given OS."),
				"list-warnings":        c.FlagSet.Bool("list-warnings", false, yellow("(Optional)")+"List warnings regarding the repository template structure."),
				"skip-upload-to-repo":  c.FlagSet.Bool("skip-upload-to-repo", false, yellow("(Optional)")+"Skip ISO image upload to the HTTP repository."),
				"replace-if-exists":    c.FlagSet.Bool("replace-if-exists", false, yellow("(Optional)")+"Replaces ISO image if one already exists in the HTTP repository."),
				"quiet":                c.FlagSet.Bool("quiet", false, green("(Flag)")+"If set, eliminates all output."),
				"debug":                c.FlagSet.Bool("debug", false, green("(Flag)")+"If set, increases log level."),
				"format":               c.FlagSet.String("format", _nilDefaultStr, "The output format. Supported values are 'json','csv','yaml'. The default format is human readable."),
				"return-id":            c.FlagSet.Bool("return-id", false, green("(Flag)")+"If set, returns the ID of the generated template. Useful for automation."),
			}
		},
		ExecuteFunc: templateBuildCmd,
		Endpoint:    ExtendedEndpoint,
		Example: `
	metalcloud-cli os-template build --list-supported --list-warnings
	metalcloud-cli os-template build --name="test-template" --source-template="ESXi/7.0.0u3" --source-iso="VMware-VMvisor-Installer-7.0.0.update03-19193900.x86_64-DellEMC_Customized-A02.iso" --kickstart="custom_kickstart.txt" --bootloader="custom_boot.CFG" --bootloader-config="custom_bootloader_config.CFG" --other-assets-json='[{\"path\":\"custom_dynamic_file_1.png\", \"isopath\":\"/dynamic_file_1.jpg\", \"type\":\"dynamic\"}, {\"path\":\"custom_dynamic_file_2.png\", \"isopath\":\"/dynamic_file_3.jpg\", \"type\":\"dynamic\"}, {\"path\":\"custom_binary_file_1.bin\", \"isopath\":\"/binary_file_1.bin\", \"type\":\"binary\"}, {\"path\":\"custom_binary_file_2.bin\", \"isopath\":\"/binary_file_2.bin\", \"type\":\"binary\"}]'
		`,
	},
	{
		Description:  "Create a diff file.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "create-diff",
		AltPredicate: "diff",
		FlagSet:      flag.NewFlagSet("create the diff of 2 files", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"file1":       c.FlagSet.String("file1", _nilDefaultStr, red("(Required)")+"Path of the first file."),
				"file2":       c.FlagSet.String("file2", _nilDefaultStr, red("(Required)")+"Path of the second file."),
				"output-file": c.FlagSet.String("output-file", _nilDefaultStr, red("(Required)")+"Path of the output file. This file must have Unix(LF) end of line encoding to be used as a patch file later."),
			}
		},
		ExecuteFunc: templateDiffCmd,
		Endpoint:    ExtendedEndpoint,
	},
	{
		Description:  "List OS source templates from a repository.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "list-repo-templates",
		AltPredicate: "repo-templates",
		FlagSet:      flag.NewFlagSet("list OS source templates from a repository ", flag.ExitOnError),
		InitFunc: func(c *Command) {
			c.Arguments = map[string]interface{}{
				"github-template-repo": c.FlagSet.String("github-template-repo", _nilDefaultStr, yellow("(Optional)")+"Override the default github url used to download template files for given OS."),
				"format":               c.FlagSet.String("format", _nilDefaultStr, "The output format. Supported values are 'json','csv','yaml'. The default format is human readable."),
			}
		},
		ExecuteFunc: templateListRepoTemplatesCmd,
		Endpoint:    ExtendedEndpoint,
	},
}

func templatesListCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {

	list, err := client.OSTemplates()

	if err != nil {
		return "", err
	}

	schema := []tableformatter.SchemaField{
		{
			FieldName: "ID",
			FieldType: tableformatter.TypeInt,
			FieldSize: 2,
		},
		{
			FieldName: "LABEL",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "NAME",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "DESCRIPTION",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "SIZE_MBYTES",
			FieldType: tableformatter.TypeInt,
			FieldSize: 5,
		},
		{
			FieldName: "BOOT_METHODS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "OS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "INSTALL_BOOTLOADER",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "OS_BOOTLOADER",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "USER_ID",
			FieldType: tableformatter.TypeInt,
			FieldSize: 5,
		},
		{
			FieldName: "CREATED",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "UPDATED",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
	}

	data := [][]interface{}{}
	for _, s := range *list {

		installBootloader := ""
		if s.OSAssetBootloaderLocalInstall != 0 {
			asset, err := client.OSAssetGet(s.OSAssetBootloaderLocalInstall)
			if err != nil {
				return "", err
			}
			installBootloader = asset.OSAssetFileName
		}
		osBootloader := ""
		if s.OSAssetBootloaderOSBoot != 0 {
			asset, err := client.OSAssetGet(s.OSAssetBootloaderOSBoot)
			if err != nil {
				return "", err
			}
			osBootloader = asset.OSAssetFileName
		}

		osData := ""

		if s.VolumeTemplateOperatingSystem != nil {
			os := *s.VolumeTemplateOperatingSystem
			osData = fmt.Sprintf("%s %s %s",
				os.OperatingSystemType,
				os.OperatingSystemVersion,
				os.OperatingSystemArchitecture)
		}

		data = append(data, []interface{}{
			s.VolumeTemplateID,
			s.VolumeTemplateLabel,
			s.VolumeTemplateDisplayName,
			s.VolumeTemplateDescription,
			s.VolumeTemplateSizeMBytes,
			s.VolumeTemplateBootMethodsSupported,
			osData,
			installBootloader,
			osBootloader,
			s.UserID,
			s.VolumeTemplateCreatedTimestamp,
			s.VolumeTemplateUpdatedTimestamp,
		})

	}

	tableformatter.TableSorter(schema).OrderBy(schema[0].FieldName).Sort(data)

	table := tableformatter.Table{
		Data:   data,
		Schema: schema,
	}
	return table.RenderTable("Templates", "", getStringParam(c.Arguments["format"]))
}

func templateCreateCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {
	obj := metalcloud.OSTemplate{}
	updatedObj, err := updateTemplateFromCommand(obj, c, client, true)
	if err != nil {
		return "", err
	}

	ret, err := client.OSTemplateCreate(*updatedObj)
	if err != nil {
		return "", err
	}

	if getBoolParam(c.Arguments["return-id"]) {
		return fmt.Sprintf("%d", ret.VolumeTemplateID), nil
	}

	return "", err
}

func templateEditCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {

	obj, err := getOSTemplateFromCommand("id", c, client, false)
	if err != nil {
		return "", err
	}
	newobj := metalcloud.OSTemplate{}
	updatedObj, err := updateTemplateFromCommand(newobj, c, client, false)
	if err != nil {
		return "", err
	}

	_, err = client.OSTemplateUpdate(obj.VolumeTemplateID, *updatedObj)

	return "", err
}

func updateTemplateFromCommand(obj metalcloud.OSTemplate, c *Command, client metalcloud.MetalCloudClient, checkRequired bool) (*metalcloud.OSTemplate, error) {
	if v, ok := getStringParamOk(c.Arguments["version"]); ok {
		obj.VolumeTemplateVersion = v
	}

	if v, ok := getStringParamOk(c.Arguments["os_ready_method"]); ok {
		obj.VolumeTemplateOSReadyMethod = v
	}

	if v, ok := getStringParamOk(c.Arguments["os_bootstrap_function_name"]); ok {
		obj.VolumeTemplateOsBootstrapFunctionName = v
	}

	if v, ok := getStringParamOk(c.Arguments["label"]); ok {
		obj.VolumeTemplateLabel = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("label is required")
		}
	}

	if v, ok := getStringParamOk(c.Arguments["display_name"]); ok {
		obj.VolumeTemplateDisplayName = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("display-name is required")
		}
	}

	if v, ok := getIntParamOk(c.Arguments["size"]); ok {
		obj.VolumeTemplateSizeMBytes = v
	}

	obj.VolumeTemplateIsOSTemplate = true

	if v, ok := getStringParamOk(c.Arguments["boot_methods_supported"]); ok {
		obj.VolumeTemplateBootMethodsSupported = v
	}

	if v, ok := getStringParamOk(c.Arguments["boot_type"]); ok {
		obj.VolumeTemplateBootType = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("boot-type is required")
		}
	}

	if v, ok := getStringParamOk(c.Arguments["description"]); ok {
		obj.VolumeTemplateDescription = v
	}

	//OS Data
	os, err := getOperatingSystemFromCommand(c)

	if err != nil {
		return nil, err
	} else if checkRequired && *os == (metalcloud.OperatingSystem{}) {
		return nil, fmt.Errorf("os flags are required")
	}
	if *os != (metalcloud.OperatingSystem{}) {
		obj.VolumeTemplateOperatingSystem = os
	}

	//Network OS Data
	nos, err := getNetworkOperatingSystemFromCommand(c)

	if err != nil {
		return nil, err
	}
	if *nos != (metalcloud.NetworkOperatingSystem{}) {
		obj.VolumeTemplateNetworkOperatingSystem = nos
	}

	// Boot options

	if _, ok := getStringParamOk(c.Arguments["os_asset_id_bootloader_local_install_id_or_name"]); ok {
		localInstallAsset, err := getOSAssetFromCommand("install_bootloader_asset", "os_asset_id_bootloader_local_install_id_or_name", c, client)
		if err != nil {
			return nil, err
		}
		obj.OSAssetBootloaderLocalInstall = localInstallAsset.OSAssetID
	}

	if _, ok := getStringParamOk(c.Arguments["os_asset_id_bootloader_os_boot_id_or_name"]); ok {
		osBootBootloaderAsset, err := getOSAssetFromCommand("os_boot_bootloader_asset", "os_asset_id_bootloader_os_boot_id_or_name", c, client)
		if err != nil {
			return nil, err
		}
		obj.OSAssetBootloaderOSBoot = osBootBootloaderAsset.OSAssetID
	}

	//Credentials

	creds, err := getCredentialsFromCommand(c, checkRequired)

	if err != nil {
		return nil, err
	}

	if *creds != (metalcloud.OSTemplateCredentials{}) {
		obj.OSTemplateCredentials = creds
	}

	if v, ok := getStringParamOk(c.Arguments["repo_url"]); ok {
		obj.VolumeTemplateRepoURL = v
	}

	obj.VolumeTemplateImageBuildRequired = getBoolParam(c.Arguments["image_build_required"])
	obj.VolumeTemplateProvisionViaOOB = getBoolParam(c.Arguments["provision_via_oob"])

	return &obj, nil
}

func getCredentialsFromCommand(c *Command, checkRequired bool) (*metalcloud.OSTemplateCredentials, error) {
	var creds = metalcloud.OSTemplateCredentials{}

	if getBoolParam(c.Arguments["use_autogenerated_initial_password"]) {

		creds.OSTemplateUseAutogeneratedInitialPassword = true

		if _, ok := getStringParamOk(c.Arguments["initial_password"]); ok {
			return nil, fmt.Errorf("--initial-password cannot be used with --use-autogenerated-initial-password")
		}

	} else {

		if v, ok := getStringParamOk(c.Arguments["initial_password"]); ok {
			creds.OSTemplateInitialPassword = v
		} else {
			if checkRequired {
				return nil, fmt.Errorf("either --initial-password or --use-autogenerated-initial-password is required")
			}
		}
	}

	if v, ok := getStringParamOk(c.Arguments["initial_user"]); ok {

		creds.OSTemplateInitialUser = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("initial-user is required")
		}
	}

	if v, ok := getIntParamOk(c.Arguments["initial_ssh_port"]); ok {
		creds.OSTemplateInitialSSHPort = v
	} else {
		if checkRequired {
			return nil, fmt.Errorf("initial-ssh-port is required")
		}
	}

	creds.OSTemplateChangePasswordAfterDeploy = getBoolParam(c.Arguments["change_password_after_deploy"])

	return &creds, nil
}

func templateDeleteCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {

	retS, err := getOSTemplateFromCommand("id", c, client, false)
	if err != nil {
		return "", err
	}
	confirm := false

	if getBoolParam(c.Arguments["autoconfirm"]) {
		confirm = true
	} else {

		confirmationMessage := fmt.Sprintf("Deleting template %s (%d).  Are you sure? Type \"yes\" to continue:",
			retS.VolumeTemplateDisplayName,
			retS.VolumeTemplateID)

		//this is simply so that we don't output a text on the command line under go test
		if strings.HasSuffix(os.Args[0], ".test") {
			confirmationMessage = ""
		}

		confirm, err = requestConfirmation(confirmationMessage)
		if err != nil {
			return "", err
		}

	}

	if !confirm {
		return "", fmt.Errorf("Operation not confirmed. Aborting")
	}

	err = client.OSTemplateDelete(retS.VolumeTemplateID)

	return "", err
}

func templateGetCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {

	showCredentials := false
	if c.Arguments["show_credentials"] != nil && *c.Arguments["show_credentials"].(*bool) {
		showCredentials = true
	}

	template, err := getOSTemplateFromCommand("id", c, client, showCredentials)
	if err != nil {
		return "", err
	}

	if err != nil {
		return "", err
	}

	schema := []tableformatter.SchemaField{
		{
			FieldName: "ID",
			FieldType: tableformatter.TypeInt,
			FieldSize: 2,
		},
		{
			FieldName: "LABEL",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "NAME",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "DESCRIPTION",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "SIZE_MBYTES",
			FieldType: tableformatter.TypeInt,
			FieldSize: 5,
		},
		{
			FieldName: "BOOT_METHODS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "OS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "USER_ID",
			FieldType: tableformatter.TypeInt,
			FieldSize: 5,
		},
		{
			FieldName: "INSTALL_BOOTLOADER",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "OS_BOOTLOADER",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "CREATED",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "UPDATED",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
	}

	data := [][]interface{}{}

	credentials := ""

	if showCredentials && template.OSTemplateCredentials != nil {

		schema = append(schema, tableformatter.SchemaField{
			FieldName: "CREDENTIALS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		})

		credentials = fmt.Sprintf("user:%s (port %d) passwd:%s (change_password_after_install:%v)",
			template.OSTemplateCredentials.OSTemplateInitialUser,
			template.OSTemplateCredentials.OSTemplateInitialSSHPort,
			template.OSTemplateCredentials.OSTemplateInitialPassword,
			template.OSTemplateCredentials.OSTemplateChangePasswordAfterDeploy)

	}
	osDetails := ""

	if template.VolumeTemplateOperatingSystem != nil {
		os := *template.VolumeTemplateOperatingSystem
		osDetails = fmt.Sprintf("%s %s %s",
			os.OperatingSystemType,
			os.OperatingSystemVersion,
			os.OperatingSystemArchitecture)
	}

	installBootloader := ""
	if template.OSAssetBootloaderLocalInstall != 0 {
		asset, err := client.OSAssetGet(template.OSAssetBootloaderLocalInstall)
		if err != nil {
			return "", err
		}
		installBootloader = asset.OSAssetFileName
	}
	osBootloader := ""
	if template.OSAssetBootloaderOSBoot != 0 {
		asset, err := client.OSAssetGet(template.OSAssetBootloaderOSBoot)
		if err != nil {
			return "", err
		}
		osBootloader = asset.OSAssetFileName
	}

	data = append(data, []interface{}{
		template.VolumeTemplateID,
		template.VolumeTemplateLabel,
		template.VolumeTemplateDisplayName,
		template.VolumeTemplateDescription,
		template.VolumeTemplateSizeMBytes,
		template.VolumeTemplateBootMethodsSupported,
		osDetails,
		template.UserID,
		installBootloader,
		osBootloader,
		template.VolumeTemplateCreatedTimestamp,
		template.VolumeTemplateUpdatedTimestamp,
		credentials,
	})

	topLine := fmt.Sprintf("Template %s (%d)\n", template.VolumeTemplateLabel, template.VolumeTemplateID)

	tableformatter.TableSorter(schema).OrderBy(
		schema[0].FieldName,
		schema[1].FieldName).Sort(data)

	table := tableformatter.Table{
		Data:   data,
		Schema: schema,
	}
	return table.RenderTable("Templates", topLine, getStringParam(c.Arguments["format"]))
}

func templateMakePublicCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {
	template, err := getOSTemplateFromCommand("id", c, client, false)

	if err != nil {
		return "", err
	}

	err = client.OSTemplateMakePublic(template.VolumeTemplateID)

	if err != nil {
		return "", err
	}

	return "", nil
}

func templateMakePrivateCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {
	template, err := getOSTemplateFromCommand("id", c, client, false)

	if err != nil {
		return "", err
	}

	user, err := getUserFromCommand("user-id", c, client)

	if err != nil {
		return "", err
	}

	if err = client.OSTemplateMakePrivate(template.VolumeTemplateID, user.UserID); err != nil {
		return "", err
	}

	return "", nil
}

func templateBuildCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {
	repoMap := make(map[string]RepoTemplate)
	err := retrieveRepositoryAssets(c, repoMap)

	if err != nil {
		return "", err
	}

	if getBoolParam(c.Arguments["list-supported"]) {
		table := createRepositoryTemplatesTable(repoMap)
		return table.RenderTable("Repository templates", "", getStringParam(c.Arguments["format"]))
	}

	_, err = handleTemplateBuild(c, client, repoMap)

	if err != nil {
		return "", err
	}

	return "", nil
}

func retrieveRepositoryAssets(c *Command, repoMap map[string]RepoTemplate) error {
	cloneOptions := new(git.CloneOptions)
	cloneOptions.Depth = 1 // We are only interested in the last commit

	if repositoryName, ok := getStringParamOk(c.Arguments["github-template-repo"]); ok {
		if userPrivateToken := os.Getenv("METALCLOUD_USER_PRIVATE_REPOSITORY_TOKEN"); userPrivateToken != "" {
			cloneOptions.Auth = &http.BasicAuth{
				Password: os.Getenv("METALCLOUD_USER_PRIVATE_REPOSITORY_TOKEN"),
			}
		}

		cloneOptions.URL = repositoryName
	} else {
		// The default repository that is used if the user doesn't specify another one
		cloneOptions.URL = "https://github.com/alexcorman/os-templates.git"
	}

	fmt.Printf("Retrieving asset templates from repository %s.\n", cloneOptions.URL)

	// Filesystem abstraction based on memory
	fs := memfs.New()

	// Git objects storer based on memory
	storer := memory.NewStorage()

	// Clones the repository into the worktree (fs) and storer all the .git
	// content into the storer
	repo, err := git.Clone(storer, fs, cloneOptions)

	if err != nil {
		if err.Error() == "authentication required" {
			return fmt.Errorf("Failed to authenticate to the given repository. Please check if the repository exists and/or the given access token is valid in the METALCLOUD_USER_PRIVATE_REPOSITORY_TOKEN environment variable.")
		}

		return err
	}

	// Retrieve the HEAD reference
	ref, err := repo.Head()

	if err != nil {
		return err
	}

	commit, err := repo.CommitObject(ref.Hash())

	if err != nil {
		return err
	}

	tree, err := commit.Tree()

	if err != nil {
		return err
	}

	// This map stores all files for a template and will be used to check if their information is correct
	repoAssetsPerTemplate := make(map[string][]TemplateAsset)

	files := tree.Files()
	files.ForEach(func(file *object.File) error {
		if file.Mode.IsRegular() {
			if strings.Count(file.Name, "/") == 2 {
				parts := strings.Split(file.Name, "/")
				templatePreffix := strings.Join(parts[:2], "/")

				if parts[2] == "template.yaml" {
					if _, ok := repoMap[templatePreffix]; !ok {
						repoMap[templatePreffix] = RepoTemplate{
							Family:       parts[0],
							SourcePath:   templatePreffix,
							TemplateFile: *file,
						}
					}
				} else {
					asset := TemplateAsset{
						file: *file,
					}

					repoAssetsPerTemplate[templatePreffix] = append(repoAssetsPerTemplate[templatePreffix], asset)
				}
			}
		}

		return nil
	})

	for templatePreffix, repoTemplate := range repoMap {
		repoTemplate.Assets = repoAssetsPerTemplate[templatePreffix]

		templateStringContents, err := repoTemplate.TemplateFile.Contents()

		if err != nil {
			return err
		}

		var templateContents TemplateContents
		err = yaml.Unmarshal([]byte(templateStringContents), &templateContents)

		if err != nil {
			return err
		}

		repoTemplate.OsTemplateContents = templateContents.OsTemplateContents

		architecture := templateContents.OsTemplateContents.OsArchitecture
		deployProcess := templateContents.OsTemplateContents.BootMethodsSupported
		bootType := templateContents.OsTemplateContents.BootType
		version := templateContents.OsTemplateContents.OsVersion

		validArchitectures := []string{osArchitecture64}
		validDeployProcesses := []string{bootMethodLocalDrives, bootMethodPxeIscsi}
		validBootTypes := []string{bootTypeUEFIOnly, bootTypeLegacyOnly}
		validMimeTypes := []string{assetMimeTypeBinary, assetMimeTypeDynamic}
		validAssetTypes := []string{assetTypeBootloader, assetTypeBootloaderConfig, assetTypeInstallerConfig, assetTypePatch, assetTypeOther}

		warnings := []string{}

		if !stringInSlice(architecture, validArchitectures) {
			warnings = append(warnings, fmt.Sprintf("Found invalid architecture %s. Valid architectures are %+q.", architecture, validArchitectures))
		}

		if !stringInSlice(deployProcess, validDeployProcesses) {
			warnings = append(warnings, fmt.Sprintf("Found invalid boot method %s. Valid boot methods are %+q.", deployProcess, validDeployProcesses))
		}

		if !stringInSlice(bootType, validBootTypes) {
			warnings = append(warnings, fmt.Sprintf("Found invalid boot type %s. Valid boot types are %+q.", bootType, validBootTypes))
		}

		if !stringInSlice(bootType, validBootTypes) {
			warnings = append(warnings, fmt.Sprintf("Found invalid boot type %s. Valid boot types are %+q.", bootType, validBootTypes))
		}

		var repoFileNames, templateFileNames []string

		for key, asset := range repoTemplate.Assets {
			fileName := strings.ReplaceAll(asset.file.Name, templatePreffix+"/", "")
			repoFileNames = append(repoFileNames, fileName)

			if asset, ok := templateContents.Assets[fileName]; ok {
				repoTemplate.Assets[key].Isopath = asset.Isopath

				if !stringInSlice(asset.Mime, validMimeTypes) {
					warnings = append(warnings, fmt.Sprintf("Found invalid mime type %s for asset %s. Valid mime types are %+q.", asset.Mime, fileName, validDeployProcesses))
				}

				if !stringInSlice(asset.Type, validAssetTypes) {
					warnings = append(warnings, fmt.Sprintf("Found invalid asset type %s for asset %s. Valid asset types are %+q.", asset.Type, fileName, validAssetTypes))
				}

				repoTemplate.Assets[key].Mime = asset.Mime
				repoTemplate.Assets[key].Type = asset.Type
				repoTemplate.Assets[key].Url = asset.Url
				repoTemplate.Assets[key].Path = asset.Path
		}

		for assetName := range templateContents.Assets {
			templateFileNames = append(templateFileNames, assetName)
		}

		fileNamesNotInTemplate := sliceDifference(repoFileNames, templateFileNames)
		fileNamesNotInRepository := sliceDifference(templateFileNames, repoFileNames)

		if len(fileNamesNotInTemplate) != 0 {
			warnings = append(warnings, fmt.Sprintf("Found the following repository files that are not in the template.yaml file: %+q.", fileNamesNotInTemplate))
		}

		if len(fileNamesNotInRepository) != 0 {
			warnings = append(warnings, fmt.Sprintf("Found the following files declared in template.yaml that are not in the repository: %+q.", fileNamesNotInRepository))
		}

		repoTemplate.Warnings = warnings

		repoTemplate.Architecture = architecture
		repoTemplate.DeployProcess = deployProcess
		repoTemplate.BootType = bootType
		repoTemplate.Version = version

		repoMap[templatePreffix] = repoTemplate
		}
	}

	fmt.Printf("Retrieved asset templates from repository %s.\n", cloneOptions.URL)
	return nil
}

func createRepositoryTemplatesTable(repoMap map[string]RepoTemplate) tableformatter.Table {
	schema := []tableformatter.SchemaField{
		{
			FieldName: "FAMILY",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "VERSION",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "ARCHITECTURE",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "DEPLOY PROCESS",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "BOOT TYPE",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
		{
			FieldName: "SOURCE TEMPLATE PATH",
			FieldType: tableformatter.TypeString,
			FieldSize: 5,
		},
	}

	data := [][]interface{}{}
	for templatePreffix, repoTemplate := range repoMap {
		var architecture, deployProcess, bootType string

		switch repoTemplate.Architecture {
		case osArchitecture64:
			architecture = "x64"
		default:
			architecture = red("unknown")
		}

		switch repoTemplate.DeployProcess {
		case bootMethodLocalDrives:
			deployProcess = "virtual_media"
		case bootMethodPxeIscsi:
			deployProcess = "pxe"
		default:
			deployProcess = red("unknown")
		}

		switch repoTemplate.BootType {
		case bootTypeUEFIOnly:
			bootType = "UEFI"
		case bootTypeLegacyOnly:
			bootType = "Legacy"
		default:
			bootType = red("unknown")
		}

		data = append(data, []interface{}{
			repoTemplate.Family,
			repoTemplate.Version,
			architecture,
			deployProcess,
			bootType,
			templatePreffix,
		})

	}

	tableformatter.TableSorter(schema).OrderBy(schema[0].FieldName).Sort(data)

	table := tableformatter.Table{
		Data:   data,
		Schema: schema,
	}

	return table
}

func handleTemplateBuild(c *Command, client metalcloud.MetalCloudClient, repoMap map[string]RepoTemplate) (string, error) {
	if name, ok := getStringParamOk(c.Arguments["name"]); ok {

		if sourceTemplateName, ok := getStringParamOk(c.Arguments["source-template"]); ok {
			imagePath, patchedText, err := checkTemplateIntegrity(c, repoMap, sourceTemplateName)

			if err != nil {
				return "", err
			}

			_, err = createTemplateAssets(c, client, repoMap, sourceTemplateName, name, imagePath, patchedText)

			if err != nil {
				return "", err
			}

		} else {
			return "", fmt.Errorf("The 'source-template' parameter must be specified with the 'name' one.")
		}
	}

	return "", nil
}

func checkTemplateIntegrity(c *Command, repoMap map[string]RepoTemplate, sourceTemplateName string) (string, string, error) {
	if _, ok := repoMap[sourceTemplateName]; !ok {
		return "", "", fmt.Errorf("Did not find source template '%s'. Please use the 'list-supported' parameter to see the supported templates.", sourceTemplateName)
	}

	var imagePath string

	if sourceISO, ok := getStringParamOk(c.Arguments["source-iso"]); ok {
		imagePath = sourceISO
	} else {
		return "", "", fmt.Errorf("The 'source-iso' parameter must be specified with the 'name' and 'source-template' ones.")
	}

	file, err := os.Open(imagePath)

	if err != nil {
		return "", "", fmt.Errorf("Image not found at path %s.", imagePath)
	}

	image, err := iso9660.OpenImage(file)

	if err != nil {
		return "", "", err
	}

	rootDir, err := image.RootDir()

	if err != nil {
		return "", "", err
	}

	children, err := rootDir.GetChildren()

	if err != nil {
		return "", "", err
	}

	var bootloaderFile *iso9660.File = nil

	for _, child := range children {
		if !child.IsDir() && child.Name() == bootloaderConfigFileName {
			bootloaderFile = child
			break
		}
	}

	if bootloaderFile == nil {
		return "", "", fmt.Errorf("Did not find bootloader config file in the given ISO image.")
	}

	bootloaderData, err := ioutil.ReadAll(bootloaderFile.Reader())

	if err != nil {
		return "", "", err
	}

	sourceTemplate := repoMap[sourceTemplateName]

	var patchAsset TemplateAsset
	foundPatchAsset := false

	for _, asset := range sourceTemplate.Assets {
		if asset.Type == assetTypePatch {

			if foundPatchAsset {
				return "", "", fmt.Errorf("Found more than one patch asset for source template '%s'. Templates should only have one patch asset for the bootloader.", sourceTemplateName)
			}

			foundPatchAsset = true
			patchAsset = asset
		}
	}

	if !foundPatchAsset {
		return "", "", fmt.Errorf("Did not find the patch file for source template '%s'.", sourceTemplateName)
	}

	patchFileStringContents, err := patchAsset.file.Contents()

	if err != nil {
		return "", "", err
	}

	diffMatchPatch := diff.New()

	patches, err := diffMatchPatch.PatchFromText(patchFileStringContents)

	if err != nil {
		return "", "", err
	}

	patchedText, _ := diffMatchPatch.PatchApply(patches, string(bootloaderData))

	//Remove tabs and blank lines, somehow they get added when applying the patch
	patchedText = strings.ReplaceAll(patchedText, "\t", "")
	patchedText = strings.TrimSpace(patchedText)

	return imagePath, patchedText, nil
}

func createTemplateAssets(c *Command, client metalcloud.MetalCloudClient, repoMap map[string]RepoTemplate, sourceTemplateName string, name string, imagePath string, patchedText string) (string, error) {
	var kickstartContents string

	if filePath, ok := getStringParamOk(c.Arguments["kickstart-append"]); ok {
		kickstartAppendFilePath := filePath

		appendFileContents, err := os.ReadFile(kickstartAppendFilePath)

		if err != nil {
			return "", fmt.Errorf("Kickstart append file not found at path %s.", kickstartAppendFilePath)
		}

		for _, asset := range repoMap[sourceTemplateName].Assets {

			if asset.Type == assetTypeInstallerConfig {
				kickstartContents, err = asset.file.Contents()

				if err != nil {
					return "", fmt.Errorf("Did not find the kickstart asset for source template '%s'.", sourceTemplateName)
				}

				kickstartContents += "\n" + string(appendFileContents)
				fmt.Printf("Appended contents from file %s to kickstart asset %s\n.", filePath, asset.file.Name)
				break
			}
		}
	}

	OsTemplateContents := repoMap[sourceTemplateName].OsTemplateContents

	createTemplateCommand := Command{
		Description:  "Create a template.",
		Subject:      "os-template",
		AltSubject:   "template",
		Predicate:    "create",
		AltPredicate: "new",
		FlagSet:      flag.NewFlagSet("create template", flag.ExitOnError),
		ExecuteFunc:  templateCreateCmd,
		Endpoint:     ExtendedEndpoint,
	}

	createTemplateCommand.Arguments = map[string]interface{}{
		"label":                              createTemplateCommand.FlagSet.String("label", name, red("(Required)")+" Template's label"),
		"display_name":                       createTemplateCommand.FlagSet.String("display-name", name, red("(Required)")+" Template's display name"),
		"size":                               createTemplateCommand.FlagSet.Int("size", _nilDefaultInt, "Template's size (bytes)"),
		"boot_methods_supported":             createTemplateCommand.FlagSet.String("boot-methods-supported", OsTemplateContents.BootMethodsSupported, red("(Required)")+" Template boot methods supported. Defaults to pxe_iscsi."),
		"os_bootstrap_function_name":         createTemplateCommand.FlagSet.String("os-bootstrap-function-name", _nilDefaultStr, "Optional property that selects the cloudinit configuration function. Can be one of: provisioner_os_cloudinit_prepare_centos, provisioner_os_cloudinit_prepare_rhel, provisioner_os_cloudinit_prepare_ubuntu, provisioner_os_cloudinit_prepare_windows."),
		"boot_type":                          createTemplateCommand.FlagSet.String("boot-type", OsTemplateContents.BootType, red("(Required)")+" Template boot type. Possible values: 'uefi_only','legacy_only' "),
		"description":                        createTemplateCommand.FlagSet.String("description", name, "Template description"),
		"os_type":                            createTemplateCommand.FlagSet.String("os-type", repoMap[sourceTemplateName].Family, red("(Required)")+" Template operating system type. For example, Ubuntu or CentOS."),
		"os_version":                         createTemplateCommand.FlagSet.String("os-version", repoMap[sourceTemplateName].Version, red("(Required)")+" Template operating system version."),
		"os_architecture":                    createTemplateCommand.FlagSet.String("os-architecture", repoMap[sourceTemplateName].Architecture, red("(Required)")+" Template operating system architecture.Possible values: none, unknown, x86, x86_64."),
		"initial_user":                       createTemplateCommand.FlagSet.String("initial-user", OsTemplateContents.InitialUser, red("(Required)")+" Template's initial username, used to verify install."),
		"initial_password":                   createTemplateCommand.FlagSet.String("initial-password", _nilDefaultStr, red("(Required)")+" Template's initial password, used to verify install."),
		"use_autogenerated_initial_password": createTemplateCommand.FlagSet.Bool("use-autogenerated-initial-password", OsTemplateContents.UseAutogeneratedInitialPassword, green("(Flag)")+" If set will automatically generate a password for the template and provide it during install via the initial_password and initial_user variables. Cannot be used withinitial-password and initial-user params."),
		"initial_ssh_port":                   createTemplateCommand.FlagSet.Int("initial-ssh-port", OsTemplateContents.InitialSSHPort, red("(Required)")+" Template's initial ssh port, used to verify install."),
		"change_password_after_deploy":       createTemplateCommand.FlagSet.Bool("change-password-after-deploy", false, "Option to change the initial_user password on the installed OS after deploy."),
		"image_build_required":               createTemplateCommand.FlagSet.Bool("image-build-required", OsTemplateContents.ImageBuildRequired, green("(Flag)")+" If set will determine the image building process building an ISO. Needed for the OOB only install process."),
		"provision_via_oob":                  createTemplateCommand.FlagSet.Bool("provision-via-oob", OsTemplateContents.ProvisionViaOob, green("(Flag)")+" If set will perform the installation process via the OOB. Always set this together with the image-build-required flag."),
		"repo_url":                           createTemplateCommand.FlagSet.String("repo-url", _nilDefaultStr, "Template's location the repository"),
		"os_ready_method":                    createTemplateCommand.FlagSet.String("os-ready-method", OsTemplateContents.OsReadyMethod, "Possible values: 'wait_for_ssh', 'wait_for_signal_from_os'. Default value: 'wait_for_ssh'."),
		"os_asset_id_bootloader_local_install_id_or_name": createTemplateCommand.FlagSet.String("install-bootloader-asset", _nilDefaultStr, "Template's bootloader asset id during install"),
		"os_asset_id_bootloader_os_boot_id_or_name":       createTemplateCommand.FlagSet.String("os-boot-bootloader-asset", _nilDefaultStr, "Template's bootloader asset id during regular server boot"),
		"version": createTemplateCommand.FlagSet.String("version", _nilDefaultStr, "Template version. Default value is 0.0.0"),
	}

	var templateID int

	_, createError := templateCreateCmd(&createTemplateCommand, client)

	if createError != nil {
		list, err := client.OSTemplates()

		if err != nil {
			return "", err
		}

		templateFound := false

		for _, s := range *list {
			if s.VolumeTemplateLabel == name {
				templateFound = true
				templateID = s.VolumeTemplateID
				break
			}
		}

		if !templateFound {
			return "", createError
		}
	}

	createAssetCommand := Command{
		Description:  "Create asset.",
		Subject:      "asset",
		AltSubject:   "asset",
		Predicate:    "create",
		AltPredicate: "new",
		ExecuteFunc:  assetCreateCmd,
		Endpoint:     DeveloperEndpoint,
	}

	assets := []Asset{}

	err := createIsoImageAsset(c, repoMap, &assets, sourceTemplateName, name, imagePath, createAssetCommand)

	if err != nil {
		return "", err
	}

	err = createBootloaderAsset(c, repoMap, &assets, sourceTemplateName, name, patchedText, createAssetCommand)

	if err != nil {
		return "", err
	}

	err = createOtherAssets(c, repoMap, &assets, sourceTemplateName, name, kickstartContents, createAssetCommand)

	if err != nil {
		return "", err
	}

	for _, asset := range assets {
		if asset.Contents != "" {
			_, err = assetCreateWithContentCmd(&asset.Command, client, []byte(asset.Contents))
		} else {
			_, err = assetCreateCmd(&asset.Command, client)
		}

		if err != nil {
			fmt.Printf("Failed to upload asset %s. Received the following error: %s\n", asset.Name, err)
		} else {
			fmt.Printf("Uploaded asset %s.\n", asset.Name)
		}
	}

	fmt.Println("Done.")

	if getBoolParam(c.Arguments["return-id"]) {
		if templateID == 0 {
			list, err := client.OSTemplates()

			if err != nil {
				return "", err
			}

			for _, s := range *list {
				if s.VolumeTemplateLabel == name {
					templateID = s.VolumeTemplateID
					break
				}
			}
		}

		return fmt.Sprintf("%d", templateID), nil
	}

	if err != nil {
		return "", err
	}

	return "", nil
}

func createIsoImageAsset(c *Command, repoMap map[string]RepoTemplate, assets *[]Asset, sourceTemplateName string, name string, imagePath string, createAssetCommand Command) error {
	// TODO: replace with real hostname after finishing development
	imageRepositoryHostname := "192.168.74.1:4022"

	if userGivenImageRepositoryHostname := os.Getenv("METALCLOUD_IMAGE_REPOSITORY_HOSTNAME"); userGivenImageRepositoryHostname != "" {
		imageRepositoryHostname = os.Getenv("METALCLOUD_IMAGE_REPOSITORY_HOSTNAME")
	}

	s := strings.Split(imagePath, "/")
	imageFilename := s[len(s)-1]

	isoPath := "/iso/" + name + "-" + imageFilename

	_, err := handleIsoImageUpload(c, imageRepositoryHostname, isoPath, imagePath)

	if err != nil {
		return err
	}

	//TODO: replace me
	assetURL := "http://" + imageRepositoryHostname + isoPath

	createIsoCommand := createAssetCommand
	createIsoCommand.FlagSet = flag.NewFlagSet("create ISO asset", flag.ExitOnError)
	createIsoCommand.Arguments = map[string]interface{}{
		"filename":               createIsoCommand.FlagSet.String("filename", imageFilename, "Asset's filename"),
		"usage":                  createIsoCommand.FlagSet.String("usage", "build_source_image", "Asset's usage."),
		"mime":                   createIsoCommand.FlagSet.String("mime", assetMimeTypeBinary, "Asset's mime type. Possible values: \""+assetMimeTypeDynamic+"\", \""+assetMimeTypeBinary+"\""),
		"url":                    createIsoCommand.FlagSet.String("url", assetURL, "Asset's source url. If present it will not read content anymore"),
		"read_content_from_pipe": createIsoCommand.FlagSet.Bool("pipe", false, "Read assets's content read from pipe instead of terminal input"),
		"template_id_or_name":    createIsoCommand.FlagSet.String("template-id", name, "Template's id or name to associate. "),
		"path":                   createIsoCommand.FlagSet.String("path", "/source-image", "Path to associate asset to."),
		"variables_json":         createIsoCommand.FlagSet.String("variables-json", _nilDefaultStr, "JSON encoded variables object"),
		"delete_if_exists":       createIsoCommand.FlagSet.Bool("delete-if-exists", true, "Automatically delete the existing asset associated with the current template."),
	}

	*assets = append(*assets, Asset{
		Name:    imageFilename,
		Command: createIsoCommand,
	})

	return nil
}

func handleIsoImageUpload(c *Command, imageRepositoryHostname string, isoPath string, imagePath string) (string, error) {
	if !getBoolParam(c.Arguments["skip-upload-to-repo"]) {

		s := strings.Split(isoPath, "/")
		imageFilename := s[len(s)-1]

		//TODO: test with hostname, not IP
		const remoteURL = "http://192.168.74.1:4080/iso"

		imageExists, err := checkRemoteFileExists(remoteURL, imageFilename)

		if err != nil {
			return "", err
		}

		if imageExists && !getBoolParam(c.Arguments["replace-if-exists"]) {
			fmt.Printf("Image %s already exists at path %s. Skipping upload. Use the 'replace-if-exists' parameter to replace the existing image.\n", imageFilename, isoPath)
			return "", nil
		}

		if imageExists {
			fmt.Printf("Replacing image %s at path %s.\n", imageFilename, isoPath)
		} else {
			fmt.Printf("Uploading new image %s at path %s.\n", imageFilename, isoPath)
		}

		if userPrivateSSHKeyPath := os.Getenv("METALCLOUD_USER_PRIVATE_OPENSSH_KEY_PATH"); userPrivateSSHKeyPath == "" {
			return "", fmt.Errorf("METALCLOUD_USER_PRIVATE_OPENSSH_KEY_PATH must be set when creating an OS template. The key is needed when uploading to the ISO repository.")
		}

		userPrivateSSHKeyPath := os.Getenv("METALCLOUD_USER_PRIVATE_OPENSSH_KEY_PATH")

		homeDir, err := os.UserHomeDir()
		if err != nil {
			return "", err
		}

		var knownHostsFilePath string

		if userGivenHostsFilePath := os.Getenv("METALCLOUD_KNOWN_HOSTS_FILE_PATH"); userGivenHostsFilePath != "" {
			knownHostsFilePath = os.Getenv("METALCLOUD_KNOWN_HOSTS_FILE_PATH")
		} else {
			knownHostsFilePath = filepath.Join(homeDir, ".ssh", "known_hosts")

			// Create the known hosts file if it does not exist.
			if _, err := os.Stat(knownHostsFilePath); errors.Is(err, os.ErrNotExist) {
				hostsFile, err := os.Create(knownHostsFilePath)

				if err != nil {
					return "", err
				}

				hostsFile.Close()
			}
		}

		hostKeyCallback, err := kh.New(knownHostsFilePath)

		if err != nil {
			return "", fmt.Errorf("Received following error when parsing the known_hosts file: %s.", err)
		}

		// Use SSH key authentication from the auth package.
		clientConfig, err := auth.PrivateKey(
			"root",
			userPrivateSSHKeyPath,
			ssh.HostKeyCallback(func(hostname string, remoteAddress net.Addr, publicKey ssh.PublicKey) error {
				var keyError *kh.KeyError
				hostsError := hostKeyCallback(hostname, remoteAddress, publicKey)

				// Reference: https://www.godoc.org/golang.org/x/crypto/ssh/knownhosts#KeyError
				//if keyErr.Want is not empty and
				if errors.As(hostsError, &keyError) {
					if len(keyError.Want) > 0 {
						// If host is known then there is key mismatch and the connection is rejected.
						fmt.Printf(`
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The key sent by the remote host is
%s.
Please contact your system administrator.
Add correct host key in %s to get rid of this message.
Host key for %s has changed and you have requested strict checking.
Host key verification failed.
`,
							serializeSSHKey(publicKey), knownHostsFilePath, hostname,
						)
						return keyError
					} else {
						// If keyErr.Want slice is empty then host is unknown.
						fmt.Printf(`
The authenticity of host '%s' can't be established.
SSH key is %s.
This key is not known by any other names.
It will be added to known_hosts file %s.
Are you sure you want to continue connecting (yes/no)?
`,
							hostname, serializeSSHKey(publicKey), knownHostsFilePath,
						)
						reader := bufio.NewReader(os.Stdin)
						input, err := reader.ReadString('\n')

						if err != nil {
							return err
						}

						// Remove \r and \n from input
						input = string(bytes.TrimSuffix([]byte(input), []byte("\r\n")))

						if input != "yes" {
							if input == "no" {
								fmt.Println("Aborting connection.")
							} else {
								fmt.Println("Invalid response given. Aborting connection.")
							}

							return keyError

						}
						return addHostKey(knownHostsFilePath, remoteAddress, publicKey)
					}
				}

				fmt.Printf("Public key exists for remote %s. Establishing connection.\n", hostname)
				return nil
			}),
		)

		if err != nil {
			return "", fmt.Errorf("Could not create SSH client config. Received error: %s", err)
		}

		// Create a new SCP client.
		scpClient := scp.NewClient(imageRepositoryHostname, &clientConfig)

		// Connect to the remote server.
		err = scpClient.Connect()
		if err != nil {
			return "", fmt.Errorf("Couldn't establish a connection to the remote server: %s", err)
		}

		defer scpClient.Close()

		fmt.Printf("Established connection to hostname %s.\n", imageRepositoryHostname)

		isoImagefile, err := os.Open(imagePath)

		if err != nil {
			return "", fmt.Errorf("Image not found at path %s.", imagePath)
		}

		remotePath := remoteDirectoryPath + isoPath

		fmt.Printf("Starting image upload to repository at path %s.\n", isoPath)
		err = scpClient.CopyFile(context.Background(), isoImagefile, remotePath, "0777")

		if err != nil {
			return "", fmt.Errorf("Error while copying file: %s", err)
		}

		fmt.Printf("Finished image upload to repository at path %s.\n", isoPath)

	} else {
		fmt.Printf("Skipped uploading image to repository at path %s.", isoPath)
	}

	return "", nil
}

func createBootloaderAsset(c *Command, repoMap map[string]RepoTemplate, assets *[]Asset, sourceTemplateName string, name string, patchedText string, createAssetCommand Command) error {
	var bootConfigPath string
	OsTemplateContents := repoMap[sourceTemplateName].OsTemplateContents

	switch OsTemplateContents.BootType {
	case bootTypeUEFIOnly:
		bootConfigPath = "/EFI/BOOT/BOOT.CFG"
	case bootTypeLegacyOnly:
		bootConfigPath = "/BOOT.CFG"
	}

	bootloaderContents := string(patchedText)
	bootloaderFileName := "BOOT.CFG"

	if filePath, ok := getStringParamOk(c.Arguments["bootloader"]); ok {
		bootloaderFilePath := filePath

		bootloaderFileContents, err := os.ReadFile(bootloaderFilePath)

		if err != nil {
			return fmt.Errorf("Bootloader file not found at path %s.", bootloaderFilePath)
		}

		bootloaderContents = string(bootloaderFileContents)

		s := strings.Split(bootloaderFilePath, "/")
		bootloaderFileName = s[len(s)-1]

		fmt.Printf("Replaced template bootloader asset with %s.\n", bootloaderFilePath)
	}

	createBootCommand := createAssetCommand
	createBootCommand.FlagSet = flag.NewFlagSet("create boot asset", flag.ExitOnError)
	createBootCommand.Arguments = map[string]interface{}{
		"filename":               createBootCommand.FlagSet.String("filename", bootloaderFileName, "Asset's filename"),
		"usage":                  createBootCommand.FlagSet.String("usage", "build_component", "Asset's usage."),
		"mime":                   createBootCommand.FlagSet.String("mime", assetMimeTypeDynamic, "Asset's mime type. Possible values: \""+assetMimeTypeDynamic+"\",\""+assetMimeTypeBinary+"\""),
		"url":                    createBootCommand.FlagSet.String("url", _nilDefaultStr, "Asset's source url. If present it will not read content anymore"),
		"read_content_from_pipe": createBootCommand.FlagSet.Bool("pipe", false, "Read assets's content read from pipe instead of terminal input"),
		"template_id_or_name":    createBootCommand.FlagSet.String("template-id", name, "Template's id or name to associate. "),
		"path":                   createBootCommand.FlagSet.String("path", bootConfigPath, "Path to associate asset to."),
		"variables_json":         createBootCommand.FlagSet.String("variables-json", _nilDefaultStr, "JSON encoded variables object"),
		"delete_if_exists":       createBootCommand.FlagSet.Bool("delete-if-exists", true, "Automatically delete the existing asset associated with the current template."),
	}

	*assets = append(*assets, Asset{
		Name:     bootloaderFileName,
		Command:  createBootCommand,
		Contents: bootloaderContents,
	})

	return nil
}

func createOtherAssets(c *Command, repoMap map[string]RepoTemplate, assets *[]Asset, sourceTemplateName string, name string, kickstartContents string, createAssetCommand Command) error {
	var otherAssets, dynamicAssets, binaryAssets []InputAsset

	if otherAssetsJSON, ok := getStringParamOk(c.Arguments["other-assets-json"]); ok {
		err := json.Unmarshal([]byte(otherAssetsJSON), &otherAssets)
		if err != nil {
			return fmt.Errorf("Invalid 'other-assets-json' value sent. The value sent must be a JSON in this format: '[{\"path\":\"<path_value>\", \"isopath\":\"<isopath_value>\", \"type\":\"<asset_type>\"}, {\"path\":\"<path_value>\", \"isopath\":\"<isopath_value>\", \"type\":\"<asset_type>\"}]'.")
		}

		for _, asset := range otherAssets {
			_, err := os.ReadFile(asset.LocalPath)

			if err != nil {
				return fmt.Errorf("Asset not found at path %s.", asset.LocalPath)
			}

			file, err := os.Open(asset.LocalPath)
			if err != nil {
				return err
			}
			defer file.Close()

			// Check that file size is below the maximum allowed.
			stat, err := file.Stat()
			if err != nil {
				return err
			}

			if stat.Size() > otherAssetsMaximumSizeBytes {
				sizeInMB := float64(stat.Size()) / (1 << 20)
				return fmt.Errorf("Asset %s has a size of %f MB which exceeds maximum allowed size of 2MB.\n", file.Name(), sizeInMB)
			}

			switch asset.Type {
			case assetJSONTypeDynamic:
				dynamicAssets = append(dynamicAssets, asset)
			case assetJSONTypeBinary:
				binaryAssets = append(binaryAssets, asset)
			default:
				return fmt.Errorf("Invalid asset type found %s. It must be one of %v.", asset.Type, []string{assetJSONTypeDynamic, assetJSONTypeBinary})
			}

		}
	}

	for _, asset := range repoMap[sourceTemplateName].Assets {
		if asset.Type == assetTypePatch {
			// We skip the patch file, as the boot file has already been created.
			continue
		}

		validMimeTypes := []string{assetMimeTypeBinary, assetMimeTypeDynamic}

		if asset.Type != assetTypeInstallerConfig  && asset.Type != assetTypeBootloaderConfig && !stringInSlice(asset.Mime, validMimeTypes) {
			// We skip the files that are not kickstarts, bootloader configs or have invalid mime type.
			continue
		}

		assetContents, err := asset.file.Contents()

		if err != nil {
			return err
		}

		assetFileName := asset.file.Name

		if asset.Type == assetTypeInstallerConfig {
			if filePath, ok := getStringParamOk(c.Arguments["kickstart"]); ok {

				if kickstartContents != "" {
					return fmt.Errorf("'kickstart' argument cannot be used alongside the 'kickstart-append' one.")
				}
				kickstartFilePath := filePath

				kickstartFileContents, err := os.ReadFile(kickstartFilePath)

				if err != nil {
					return fmt.Errorf("Kickstart file not found at path %s.", kickstartFilePath)
				}

				assetContents = string(kickstartFileContents)
				assetFileName = kickstartFilePath

				fmt.Printf("Replaced template kickstart asset with %s.\n", kickstartFilePath)
			} else if kickstartContents != "" {
				// If we have a kickstart file and the kickstart-append option was used, we will use the string with the appended text
				assetContents = kickstartContents
			}
		} else if asset.Type == assetTypeBootloaderConfig {
			if filePath, ok := getStringParamOk(c.Arguments["bootloader-config"]); ok {
				bootloaderConfigFilePath := filePath

				bootloaderConfigFileContents, err := os.ReadFile(bootloaderConfigFilePath)

				if err != nil {
					return fmt.Errorf("Bootloader configuration file not found at path %s.", bootloaderConfigFilePath)
				}

				assetContents = string(bootloaderConfigFileContents)
				assetFileName = bootloaderConfigFilePath

				fmt.Printf("Replaced bootloader config asset with %s.\n", bootloaderConfigFilePath)
			}
		} else {
			switch asset.Mime {
			case assetMimeTypeBinary:
				for _, binaryAsset := range binaryAssets {
					fileContents, _ := os.ReadFile(binaryAsset.LocalPath)

					if asset.Isopath == binaryAsset.IsoPath {
						assetContents = string(fileContents)
						assetFileName = binaryAsset.LocalPath

						fmt.Printf("Replaced binary asset with %s.\n", assetFileName)
					}
				}
			case assetMimeTypeDynamic:
				for _, dynamicAsset := range dynamicAssets {
					fileContents, _ := os.ReadFile(dynamicAsset.LocalPath)

					if asset.Isopath == dynamicAsset.IsoPath {
						assetContents = string(fileContents)
						assetFileName = dynamicAsset.LocalPath

						fmt.Printf("Replaced dynamic asset with %s.\n", assetFileName)
					}
				}
			}
		}

		s := strings.Split(assetFileName, "/")
		assetName := s[len(s)-1]

		createOtherAssetCommand := createAssetCommand
		createOtherAssetCommand.FlagSet = flag.NewFlagSet("create asset "+assetName, flag.ExitOnError)
		createOtherAssetCommand.Arguments = map[string]interface{}{
			"filename":               createOtherAssetCommand.FlagSet.String("filename", assetName, "Asset's filename"),
			"usage":                  createOtherAssetCommand.FlagSet.String("usage", "build_component", "Asset's usage."),
			"mime":                   createOtherAssetCommand.FlagSet.String("mime", asset.Mime, "Asset's mime type. Possible values: \""+assetMimeTypeDynamic+"\",\""+assetMimeTypeBinary+"\""),
			"url":                    createOtherAssetCommand.FlagSet.String("url", _nilDefaultStr, "Asset's source url. If present it will not read content anymore"),
			"read_content_from_pipe": createOtherAssetCommand.FlagSet.Bool("pipe", false, "Read assets's content read from pipe instead of terminal input"),
			"template_id_or_name":    createOtherAssetCommand.FlagSet.String("template-id", name, "Template's id or name to associate. "),
			"path":                   createOtherAssetCommand.FlagSet.String("path", asset.Isopath, "Path to associate asset to."),
			"variables_json":         createOtherAssetCommand.FlagSet.String("variables-json", _nilDefaultStr, "JSON encoded variables object"),
			"delete_if_exists":       createOtherAssetCommand.FlagSet.Bool("delete-if-exists", true, "Automatically delete the existing asset associated with the current template."),
		}

		*assets = append(*assets, Asset{
			Name:     assetName,
			Command:  createOtherAssetCommand,
			Contents: assetContents,
		})
	}

	return nil
}

func templateDiffCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {
	var filePath1, filePath2, outputFilePath string

	if file1, ok := getStringParamOk(c.Arguments["file1"]); ok {
		filePath1 = file1
	} else {
		return "", fmt.Errorf("Did not find the 'file1' parameter.")
	}

	if file2, ok := getStringParamOk(c.Arguments["file2"]); ok {
		filePath2 = file2
	} else {
		return "", fmt.Errorf("Did not find the 'file2' parameter.")
	}

	if outputFile, ok := getStringParamOk(c.Arguments["output-file"]); ok {
		outputFilePath = outputFile
	} else {
		return "", fmt.Errorf("Did not find the 'output-file' parameter.")
	}

	fileContents1, err := os.ReadFile(filePath1)

	if err != nil {
		return "", err
	}

	fileContents2, err := os.ReadFile(filePath2)

	if err != nil {
		return "", err
	}

	diffMatchPatch := diff.New()

	diffs := diffMatchPatch.DiffMain(string(fileContents1), string(fileContents2), false)
	patches := diffMatchPatch.PatchMake(diffs)
	patchText := diffMatchPatch.PatchToText(patches)

	file, err := os.Create(outputFilePath)

	if err != nil {
		return "", nil
	}
	defer file.Close()

	writer := bufio.NewWriter(file)

	_, err = fmt.Fprintf(writer, "%s", patchText)
	if err != nil {
		return "", nil
	}

	writer.Flush()
	return "", nil
}

func templateListRepoTemplatesCmd(c *Command, client metalcloud.MetalCloudClient) (string, error) {
	repoMap := make(map[string]RepoTemplate)
	err := retrieveRepositoryAssets(c, repoMap)

	if err != nil {
		return "", err
	}

	table := createRepositoryTemplatesTable(repoMap)
	return table.RenderTable("Repository templates", "", getStringParam(c.Arguments["format"]))
}

func getOSTemplateFromCommand(paramName string, c *Command, client metalcloud.MetalCloudClient, decryptPasswd bool) (*metalcloud.OSTemplate, error) {
	v, err := getParam(c, "template_id_or_name", paramName)
	if err != nil {
		return nil, err
	}

	id, label, isID := idOrLabel(v)

	if isID {
		return client.OSTemplateGet(id, decryptPasswd)
	}

	list, err := client.OSTemplates()
	if err != nil {
		return nil, err
	}

	for _, s := range *list {
		if s.VolumeTemplateLabel == label {
			return &s, nil
		}
	}

	if isID {
		return nil, fmt.Errorf("template %d not found", id)
	}

	return nil, fmt.Errorf("template %s not found", label)
}

func getUserFromCommand(paramName string, c *Command, client metalcloud.MetalCloudClient) (*metalcloud.User, error) {
	user, err := getParam(c, "user_id", paramName)
	if err != nil {
		return nil, err
	}

	id, email, isID := idOrLabel(user)

	if isID {
		return client.UserGet(id)
	} else {
		return client.UserGetByEmail(email)
	}
}

func stringInSlice(a string, list []string) bool {
	for _, b := range list {
		if b == a {
			return true
		}
	}
	return false
}

func sliceDifference(slice1 []string, slice2 []string) []string {
	var diff []string

	for _, s1 := range slice1 {
		found := false

		for _, s2 := range slice2 {
			if s1 == s2 {
				found = true
				break
			}
		}

		if !found {
			diff = append(diff, s1)
		}
	}

	return diff
}

// Add host key if host is not found in known_hosts.
// The return object is the error, if nil then connection proceeds, else connection stops.
func addHostKey(knownHostsFilePath string, remoteAddress net.Addr, publicKey ssh.PublicKey) error {
	knownHostsFile, err := os.OpenFile(knownHostsFilePath, os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		return fmt.Errorf("Hosts file not found at path %s.", knownHostsFilePath)
	}
	defer knownHostsFile.Close()

	fileBytes, err := os.ReadFile(knownHostsFilePath)

	// We add an empty line if the file doesn't end in one and if it's not empty to begin with.
	if len(fileBytes) > 0 && string(fileBytes[len(fileBytes)-1]) != "\r" && string(fileBytes[len(fileBytes)-1]) != "\n" {
		_, err = knownHostsFile.WriteString("\n")

		if err != nil {
			return err
		}
	}

	knownHosts := kh.Normalize(remoteAddress.String())
	_, err = knownHostsFile.WriteString(kh.Line([]string{knownHosts}, publicKey))

	fmt.Printf("Added key %s to known_hosts file %s.", serializeSSHKey(publicKey), knownHostsFilePath)
	return err
}

func serializeSSHKey(key ssh.PublicKey) string {
	return key.Type() + " " + base64.StdEncoding.EncodeToString(key.Marshal())
}

func checkRemoteFileExists(remoteURL string, fileName string) (bool, error) {
	resp, err := netHTTP.Get(remoteURL)

	if err != nil {
		return false, err
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return false, err
	}

	responseBody := string(body)
	return strings.Contains(responseBody, fileName), nil
}
